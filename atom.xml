<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[备忘录]]></title>
  <subtitle><![CDATA[苟利国家生死以，岂因祸福避趋之。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://luengzeegin.github.io/"/>
  <updated>2017-07-14T11:30:06.016Z</updated>
  <id>https://luengzeegin.github.io//</id>
  
  <author>
    <name><![CDATA[Lueng Zeegin]]></name>
    <email><![CDATA[luengzg@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[深度探索C++对象模型、E、ME笔记]]></title>
    <link href="https://luengzeegin.github.io/2017/07/14/inside%20obejct%20model_e_me/"/>
    <id>https://luengzeegin.github.io/2017/07/14/inside obejct model_e_me/</id>
    <published>2017-07-13T16:00:00.000Z</published>
    <updated>2017-07-14T11:30:06.016Z</updated>
    <content type="html"><![CDATA[<h2 id="深度探索C++对象模型">深度探索C++对象模型</h2><p>1.<em>struct</em> 和 <em>class</em>的一点点区别 p16</p>
<p>2.支持多态的形式 p25</p>
<p>3.一个类对象的内存 p27<br><a id="more"></a><br>4.* 和 &amp; 支持多态的原因 p33</p>
<p>5.合成构造函数的条件 p47</p>
<ul>
<li><p>没有 default 构造函数</p>
<ul>
<li>基类有构造函数</li>
<li>类成员有构造函数</li>
</ul>
</li>
<li><p>有 default ctor 并且有 user code 时，先扩展已有的 ctor，再插入 user code ，再合成默认构造函数</p>
</li>
<li><p>带虚基类的类</p>
</li>
</ul>
<p>6.有效的 copy ctor P53</p>
<p>7.NRV P67</p>
<p>8.copy ctor 的讨论 P72</p>
<p>9.初始值列表 P77</p>
<p>10.类大小的影响因素、空 class 有 1byte P84</p>
<p>11.empty virtual base class 的优化 P86</p>
<p>12.data member 的存储 P94</p>
<p>13.单一继承对象布局、为什么要 pading P105</p>
<p>14.多重继承数据布局 P115</p>
<p>15.虚拟继承数据布局 P121 P123</p>
<p>16.指向 data member 的指针 offset P132</p>
<p>17.区分没有指向任何 data member 的指针与指向第一个 data member 的指针 P130 P131</p>
<p>18.member 各种调用方式</p>
<ul>
<li>name mangling P144</li>
<li>static member func P149</li>
</ul>
<p>19.c++ 多态 P153</p>
<p>20.vtb的实现 P155</p>
<p>21.单一继承的 vtb 布局 P157</p>
<p>22.trunk 技术 P163</p>
<p>23.多重继承的 vtb 布局 P165</p>
<p>24.调整指针 offset P166</p>
<p>25.虚拟继承的 vtb 布局 P169</p>
<p>26.指向 member func 的指针 P175</p>
<p>27.对 virtual member func 取址得索引值 P176</p>
<p>28.函数指针的 evaluate P178</p>
<p>29.inline 的作用以及与宏的区别 P183</p>
<p>30.处理 inline 的两个阶段 P184</p>
<p>31.inline 的形参绑定 P185</p>
<p>32.inline 局部变量的展开 P187</p>
<p>33.纯虚函数的作用 P193</p>
<p>34.Plain OI’Data P196</p>
<p>35.global object / heap object / local object P197</p>
<p>36.explicit initialzation list P200</p>
<p>37.vfunc 的膨胀作用 P203</p>
<p>38.ctor 扩展操作 P206</p>
<p>39.虚拟继承基类 ctor 的 trick(参数) P210</p>
<p>40.vptr 初始化操作 P216、P218</p>
<p>41.不表现 bitwise copy 语意的 ctor P220</p>
<p>42.派生类初始化基类 ctor P223</p>
<p>43.析构函数 P231</p>
<p>44.dtor 的扩展顺序 P234</p>
<p>45.全局对象的 munch 策略 P243、P245</p>
<p>46.局部静态对象 P247</p>
<p>47.new 的运行步骤 P254</p>
<p>48.new 返回 1Byte 内存 P257</p>
<p>49.placement new P264</p>
<p>50.copy ctor 和 assignment P269</p>
<p>51.临时对象的生命周期 P271、P273</p>
<p>52.临时对象的优化 P277</p>
<p>53.template 的类型决议 P290</p>
<p>54.exception 运行过程 P298、P303、P305</p>
<p>55.new 抛出 exception P301</p>
<p>56.type_info P312、P315</p>
<p>57.down_cast P309</p>
<p>58.down_cast 的负担 P310</p>
<hr>
<h2 id="Effective_C++">Effective C++</h2><p>1.enum hack P15 </p>
<p>2.宏展开 P16</p>
<p>3.运算符函数 const 的原因 P19</p>
<p>4.const 的意义 P21、P23</p>
<p>5.编译单元的 non-local-static 初始化 P30</p>
<p>6.copy ctor 函数与 copy assignment 区别 P60</p>
<p>7.RAII P66</p>
<p>8.数据的封装 P99</p>
<p>9.this 指针的 trick P121</p>
<p>10.copy and swap P132</p>
<p>11.Pimpl P142</p>
<p>12.纯虚函数的特点 P162</p>
<p>13.NVI、模板设计模式、策略模式 P170</p>
<p>14.动态绑定与静态绑定 P180</p>
<p>15.显式接口与隐式接口 P200</p>
<hr>
<h2 id="More_Effective">More Effective</h2><p>1.const 时 reference 与 pointer 的区别</p>
<p>2.dctor 不会析构半成品 P53</p>
<p>3.by pointer、ref、name catch exception P68</p>
<p>4.虚函数、多重继承、虚拟基类、RTTI的主要成本 P121</p>
<p>5.单例模型 P132</p>
<p>6.unique_ptr 条款28</p>
<p>7.share_ptr 条款29</p>
<p>8.什么时候使用RC P212</p>
<p>9.double-dispatching 条款31</p>
<ul>
<li>如何处理多态</li>
<li>如何维护</li>
</ul>
<p>10.如何设计一个 class P257</p>
<p>11.继承类中赋值语句的处理 P264</p>
<p>12.有用的抽象 P267</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="深度探索C++对象模型">深度探索C++对象模型</h2><p>1.<em>struct</em> 和 <em>class</em>的一点点区别 p16</p>
<p>2.支持多态的形式 p25</p>
<p>3.一个类对象的内存 p27<br>]]>
    
    </summary>
    
      <category term="c++" scheme="https://luengzeegin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Note in c++ prime 5th (chap13-16)]]></title>
    <link href="https://luengzeegin.github.io/2017/02/15/cpp-prime-chap-13-16/"/>
    <id>https://luengzeegin.github.io/2017/02/15/cpp-prime-chap-13-16/</id>
    <published>2017-02-15T14:39:26.000Z</published>
    <updated>2017-02-28T08:27:40.180Z</updated>
    <content type="html"><![CDATA[<p>有时候，我在写代码的时候忘记了一些概念，就会回头看看我之前写的东西。但是我发现有些概念好像还是很模糊，而且也有点偏颇，不是十分完整，如果您看到还理解的话，建议您去 MSDN 找相应的文档看看。<br><a id="more"></a></p>
<h2 id="拷贝控制">拷贝控制</h2><p>1.拷贝控制操作是指：拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值运算符、析构函数。</p>
<p>2.如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<p>3.拷贝初始化不仅在我们用 <strong>=</strong> 定义变量时会发生，在下列情况下也会发生 ：</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<p>4.拷贝构造函数第一个参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功，因为为了调用拷贝构造函数，我们必须拷贝它的实参，但是为了拷贝实参，我们又需要调用拷贝构造函数，如此循环。</p>
<p>5.如果我们使用的初始化值要求通过一个 explicit 的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>) ; <span class="comment">// 正确：直接初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>; <span class="comment">// 错误：接受大小参数的构造函数时 explicit 的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)</span> </span>; <span class="comment">// f的参数进行拷贝初始化</span></span><br><span class="line">f(<span class="number">10</span>) ; <span class="comment">// 错误：不能用一个 explicit 的构造函数拷贝一个实参</span></span><br><span class="line">f(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>)); <span class="comment">// 正确：从一个 int 直接构造一个临时的 vector</span></span><br></pre></td></tr></table></figure></p>
<p>6.在拷贝初始化过程中，编译器可以(但不是必须)跳过拷贝/移动构造函数，直接创建对象。但是，即使编译器略过了拷贝/构造函数，但在这个程序点上，拷贝/移动构造函数必须时存在且可访问的，例如，不能使 private 的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-9999"</span>; </span><br><span class="line"><span class="comment">// 拷贝初始化</span></span><br></pre></td></tr></table></figure></p>
<p>改写为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">null_book</span><span class="params">("9-999-9999")</span></span>; </span><br><span class="line"><span class="comment">// 编译器略过了拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>7.为了与内置类型的赋值保持一致，赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
<p>8.如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。对于某些类来说，合成拷贝赋值运算符用来禁止该类型对象的赋值。详见 c++ prime 5th 中文版的450页。</p>
<p>9.析构函数执行与构造函数相反的操作：构造函数初始化的非 static 数据成员，还可能做一些其他工作：析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。</p>
<p>10.析构函数是类的一个成员函数，名字由波浪号接类名构成。他没有返回值，也不接受参数。析构函数不能重载，因此对于一个给定类，只会有唯一一个析构函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Foo();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p>
<p>11.在一个构造函数中，成员的初始化是在函数体执行之前完成的，并且按照它们在类中出现的顺序进行初始化。</p>
<p>12.在一个析构函数中，首先执行函数体，然后按照成员初始化顺序的逆序，将对象在生存期分配的所有资源销毁。</p>
<p>13.内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。当我们隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象。</p>
<p>14.无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li>变量在离开其作用时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器(无论是标准库容器还是数组)被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<p>15.当指向一个对象的引用或者指针离开作用于的时候，析构函数不会执行。</p>
<p>16.对于某些类，合成析构函数被用来阻止该类型的对象被销毁，如果不是这种情况，合成析构函数的函数体就为空。</p>
<p>17.成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的。</p>
<p>18.三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。</p>
<p>19.如果一个类需要(自定义)一个析构函数，我们<strong>几乎可以</strong>肯定它特需要(自定义)一个拷贝构造函数和(自定义)一个拷贝赋值运算符。</p>
<pre><code><span class="attribute">     析  构
   /        \
赋值 =====</span>=<span class="string"> 拷贝</span>
</code></pre><p>20.如果一个类需要一个拷贝构造函数，<strong>几乎可以</strong>肯定它也需要一个拷贝赋值运算符，反之亦然。无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必意味着也需要析构函数。</p>
<p>21.我们可以通过将拷贝控制成员定义为 =default 来显示地要求编译器生成合成的版本。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>22.大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值函数，无论是显式还是隐式。</p>
<p>23.删除的函数是一种我们虽然声明了它们，但不能以任何方式使用它们的函数。我们可以在函数参数列表后面加上 =delete 来说明该函数是删除的。</p>
<p>24.=delete 与 =default 的不同是 =delete 必须出现在函数第一次声明的时候使得编译器在第一个函数时删除的，以便禁止试图使用它的操作。而 =default 直到编译器生成代码时才需要。<br>在另一方面，我们可以对任何函数指定 =delete(我们只能对编译器可以合成的默认构造函数或者拷贝构造函数成员使用 =default)，虽然删除函数的主要用途时禁止拷贝控制成员，但是当我们希望引导函数匹配过程时，删除函数有时候也是有用的。</p>
<p>25.析构函数不能是删除的成员，对于析构函数已删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。</p>
<p>26.本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。详见 c++ prime 5th 中文版 p450。</p>
<p>27.希望阻止拷贝的类应该使用 =delete 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为 private。</p>
<p>28.一个类的行为是像一个值还是像一个指针，却决于我们如何确定此类型对象的拷贝语义。</p>
<p>29.类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和元对象是完全独立的。改变副本不会对原对象产生影响，反之亦然。</p>
<p>30.类的行为像指针，意味着它是共享的。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据，改变副本数据会应该原对象，反之亦然。</p>
<p>31.io类型 和 unique_ptr 不允许拷贝或赋值，因此它们的行为既不像值也不像指针。</p>
<p>32.要使一个类的行为像值，对于类管理的每个资源，每个对象都应该拥有一份自己的拷贝(即需要定义拷贝函数)。</p>
<p>33.当我们在编写赋值运算符时，我们需要注意：</p>
<ul>
<li>如果将一个对象赋予它本身时，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和拷贝函数的工作。</li>
</ul>
<p>34.一个好的赋值运算符应该是先将右侧运算对象拷贝到一个局部临时对象中，在拷贝完成之后，销毁左侧运算对象的现有成员就是安全的了，一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p>
<p>35.要使一个类的行为像指针，最好的方法就是使用 shared_ptr来管理类中的资源。当我们想要直接管理资源的时候，我们可以使用引用计数。</p>
<p>36.关于引用计数的工作方式，详见 c++ prime 5th 中文版的 p455。</p>
<p>37.为了交换两个对象，我们需要进行一次拷贝和两次赋值。</p>
<p>38.与拷贝控制成员不同，swap 并不是必要的。但是，对于分配了资源的类，定义 swap 可能是一种重要的优化手段。</p>
<p>39.使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。因为在改变左侧运算对象之前，拷贝右侧运算对象保证了自赋值的正确。</p>
<p>40.公共的工作应该放在 private 的工具函数中完成。</p>
<p>41.某些类需要在运行时分配可变大小的内存空间，可以使用标准库容器来保存它们的数据。</p>
<p>42.标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝。IO 类和 unique_ptr 类可以移动但不能拷贝。</p>
<p>43.右值引用就是必须绑定到右值的引用，我们可以通过 &amp;&amp; 来获得右值引用。</p>
<p>44.右值引用有一个重要的性质 —- 只能绑定到一个将要销毁的对象。</p>
<p>45.一般而言，一个左值表达式表达的是一个对象的身份(地址)，而一个右值表达式表示的是对象的值。</p>
<p>46.我们不能将左值引用绑定到要求转换的表达式、字面常量、返回右值的表达式。</p>
<p>47.我们可以将一个右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式，但是不能将一个右值引用直接绑定到一个左值上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">42</span>;             </span><br><span class="line"><span class="keyword">int</span> &amp;r = i;             </span><br><span class="line"><span class="comment">//正确： r 引用 i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;           </span><br><span class="line"><span class="comment">//错误： 不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;       </span><br><span class="line"><span class="comment">//错误： i * 42 是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>; </span><br><span class="line"><span class="comment">//正确：我们可以将一个 const 的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;     </span><br><span class="line"><span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p>
<p>48.返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式。</p>
<p>49.返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。虽然我们不能将一个左值引用绑定到这类表达式上，但是我们可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式上。</p>
<p>50.左值和右值的区别在于：左值有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时变量。</p>
<p>51.右值引用指向的对象是将被销毁的，并且这个对象没有其他用户。这意味着使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<p>52.变量或变量表达式都是左值的，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1;</span><br></pre></td></tr></table></figure></p>
<p>53.我们可以通过调用 move 函数来获得绑定到左值上的右值引用，但是这就意味着移后原对象可以被销毁、赋值，但是不能使用这个对象的值。</p>
<p>54.使用 move 的代码应该使用 std::move 而不是 move 。这样做可以避免潜在的名字冲突。</p>
<p>55.移动构造函数的第一个参数是该类类型的一个右值引用，任何额外的参数都必须有默认实参。</p>
<p>56.移动构造函数在完成资源移动之后，要保证移后源对象的资源是无害的、可析构的，因为移动构造函数不分配任何新内存，而且原对象不再指向被移动资源。</p>
<p>57.移动操作不应抛出任何异常。</p>
<p>58.不跑出异常的移动构造函数和移动赋值运算符都必须标记为 noexcept。</p>
<p>59.只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或者移动赋值运算符。</p>
<p>60.与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。如果我们显式地要求编译器生成 =default 的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。</p>
<p>61.关于什么时候会将合成的移动操作定义为删除的函数详见 c++ prime 5th 中文版 p476。总而言之，就是有对象不能移动。</p>
<p>62.定义了一个移动构造函数或移动赋值函数运算符的类必须也定义自己的拷贝操作。否则，合成拷贝构造函数和拷贝赋值运算符默认地被定义为删除的。</p>
<p>63.如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。</p>
<p>64.关于三/五法则详见 c++ prime 5th 中文版的 p478。</p>
<p>65.在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当我们保证移动操作是安全的，才能可以使用 std::move。</p>
<p>66.区分移动和拷贝的重载函数通常有一个版本接受一个 const T&amp;,而另一个版本接受一个 T&amp;&amp;。</p>
<p>67.我们可以通过在参数列表放置一个引用限定符来声明一个右值和左值引用成员函数。</p>
<p>68.引用限定符可以是 &amp; 或 &amp;&amp;，分别指出 this 可以指向一个左值或右值。引用限定符只能用于非 static 成员函数，且必须同时出现在函数的声明和定义中，并且引用限定符必须跟随在 const 限定符之后。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="keyword">const</span></span>;    <span class="comment">//错误</span></span><br><span class="line"><span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p>
<p>69.如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p>
<h2 id="重载运算与类型转换">重载运算与类型转换</h2><p>1.重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后定义的运算符号组成，和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>2.重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。</p>
<p>3.除了重载的函数调用运算符 operator() 之外，其他重载运算符不能含有默认实参。</p>
<p>4.当一个重载的运算符是成员函数时，它的左侧运算对象会绑定到隐式的 this 指针上，所以成员运算符函数的显式参数数量比运算对象的数量少一个。</p>
<p>5.对于一个运算符函数来说，它是类的成员或者它至少含有一个类类型的参数。</p>
<p>6.我们只能重载已有的运算符，而无权发明新的运算符号，我们也无法改变该运算符的含义。</p>
<p>7.我们将运算符作用于类型正确的实参，同时我们也能像调用普通函数一样调用运算符函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1 + data2;              <span class="comment">//普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1,data2);     <span class="comment">//等价的函数调用。</span></span><br></pre></td></tr></table></figure></p>
<p>8.通常情况下，不应该重载逗号、区地址、逻辑与、逻辑或运算符。</p>
<p>9.只有当操作的含义对于用户来说清晰明了时才使用运算符重载，关于运算符重载的一些建议详见 c++ prime 5th 中文版的 p492。</p>
<p>10.关于怎么选择将运算符定义为成员函数还是普通的非成员函数详见 c++ prime 5th 中文版的 p493。</p>
<p>11.因为 ostream 向流写入内容的时候会改变其状态，所以输出运算符的第一个形参时一个非常量 ostream 对象的引用。第二个形参一本来说时一个常量引用，因为我们希望避免复制实参。</p>
<p>12.输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
<p>13.与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不是类的成员函数，否则，它们的左侧运算对象将是我们的类的一个对象。</p>
<p>14.IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元。</p>
<p>15.输入运算符的第一个形参时运算符将要读取的流的引用，第二个形参时将要读入到的非常量对象的引用。</p>
<p>16.输入运算符必须处理输入可能出现的失败的情况，而输出运算符不需要。在执行输入运算符时可能发生下列错误详见 c++ prime 5th 中文版的p495 。</p>
<p>17.当读取操作发生错误时，输入运算符应该负责从错误中恢复。</p>
<p>18.通常情况下，输入运算符只设置 failbit，除此之外，设置 eofbit 表示文件耗尽，设置 badbit 表示流被破坏。最好的方式是由 IO 标准库自己来标识这些错误。</p>
<p>19.通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。</p>
<p>20.如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p>
<p>21.如果某个类在逻辑上有相等的含义，则该类应该定义 operator== ，这样做可以使得用户更容易使用标准库算法来处理这个类。</p>
<p>22.关于相等运算符的设计准则详见 c++ prime 5th 中文版的p498。</p>
<p>23.通常情况下关系运算符应该<br>    1.定义顺序关系，令其与关联容器中对关键字的要求一致。<br>    2.如果类同时也含有 == 运算符的话，则定义一种关系令其和 == 保持一致。特别是如果两个对象是 != 的，那么一个对象应该 &lt; 另一个。</p>
<p>24.如果存在唯一一种逻辑可靠的 &lt; 定义，则应该考虑为这个类定义 &lt; 运算符。如果类同时还包含 == ，则当且仅当 &lt; 的定义和 == 产生的结果一致才定义 &lt; 运算符。</p>
<p>25.我们可以重载值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</p>
<p>26.赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</p>
<p>27.下标运算符必须是成员函数。</p>
<p>28.如果一个类包含下标运算符，则它通常会定义一个返回普通引用的版本，和一个类的常量成员并且返回常量引用，因为下标可以出现在赋值运算符的任意一端。</p>
<p>29.定义递增和递减运算符的类应该同时定义前置版本和后置版本，并且这些运算符通常应该被定义成类的成员。</p>
<p>30.为了与内置版本保持一致，前置运算符应该返回递增或者递减后对象的引用，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的是一个值不是引用。</p>
<p>31.普通的重载形式无法区别这两种运算符，为了解决这个问题，后置版本接受一个额外的、但是不被使用的 int 类型的形参。当我们使用后置运算符的时候，编译器为这个形参提供一个值为 0 的实参。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>) ;  </span><br><span class="line"><span class="comment">//调用后置版本，尽管传入的值会被运算符函数忽略，</span></span><br><span class="line"><span class="comment">//但必不可少，因为编译器通过它才能知道应该使用后置版本。</span></span><br><span class="line">p.<span class="keyword">operator</span>++()  ;   <span class="comment">//调用前置版本。</span></span><br></pre></td></tr></table></figure></p>
<p>32.箭头运算符必须是类的成员，解引用运算符通常也是类的成员但是也是会有例外。</p>
<p>33.对于形如 point-&gt;mem 的表达式对象来说，point 必须是指向类对象的指针或者是一个重载了 operator-&gt; 的类的对象。<br>根据 point 类型不同 point-&gt; 分别等价于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;           </span><br><span class="line">poing.<span class="keyword">operator</span>()-&gt;mem;</span><br></pre></td></tr></table></figure></p>
<p>34.重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p>
<p>35.函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p>
<p>36.如果类的定义了调用运算符，我们可以像使用函数一样使用该类的对象，因此这个类的对象称作函数对象。</p>
<p>37.函数对象类除了 operator()之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。</p>
<p>38.当我们编写一个 lambba 后，编译器将该表达式翻译成一个未命名类的未命名对象，在 lambda 表达式产生的类中含有一个重载的函数调用运算符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据单词的长度进行排序，对于长度相同的单词按照字母表的顺序排序</span></span><br><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b))</span><br><span class="line">&#123;   <span class="keyword">return</span> s1.size &lt; s2.size    &#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">class</span> ShorterString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> <span class="keyword">const</span></span><br><span class="line">        </span>&#123;   <span class="keyword">return</span> s1.size() &lt; s2.size()    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>39.在默认情况下，lambda 不能改变它捕获的变量，因此在默认情况下，由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数。如果 lambda 被声明为可变，则调用运算符就不是 const 的了。</p>
<p>40.当一个 lambda 表达式通过引用捕获变量时，将由程序负责确保 lambda 执行时引用所引的对象确实存在，因此编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。<br>相反，通过值捕获的变量被拷贝到 lambda 中，这个 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</p>
<p>41.lambda 表达式产生的类不含默认构造函数、赋值运算符以及默认析构函数;它是否含有默认的拷贝/移动构造函数则通常根据捕获的数据成员类型而定。</p>
<p>42.关于标准库函数对象，详见 c++ prime 5th 中文版的 p510。</p>
<p>43.表示运算符的函数对象类常用来替换算法中的默认运算符，需要特别注意的是对于函数同样适用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(nameTable.begin(), nameTable.end(), less&lt;<span class="built_in">string</span>*&gt;());</span><br></pre></td></tr></table></figure></p>
<p>44.每个 lambda 有它自己唯一的、未命名的类类型；函数及函数指针的类型则由其返回值类型和是实参类型决定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建从运算符到函数指针的映射关系，其中函数接受两个 int 、 返回一个 int</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span> <span class="keyword">int</span>)&gt; binops;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="keyword">auto</span> mod = [] (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> i % j; &#125;</span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;); <span class="comment">// 将 add 的指针添加到 binops 中</span></span><br><span class="line">binops.insert(&#123;<span class="string">"%"</span>, mod&#125;); </span><br><span class="line"><span class="comment">// 错误：mod 不是一个函数指针，lambda 有它自己的类类型，与存储在 binops 中的类型不匹配</span></span><br></pre></td></tr></table></figure></p>
<p>45.两个不同类型的可调用对象有可能共享同一种调用形式，一种调用形式对应一个函数类型。<br>调用形式指明了调用返回的类型以及传递给调用的实参类型。</p>
<p>46.关于 function 的操作详见 c++ prime 5th 中文版的 p512。</p>
<p>47.function 是一个模板，当创建一个具体的 function 类型时我们必须提供 function 类型能表示的对象的调用形式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;                                <span class="comment">//函数指针</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();                          <span class="comment">//函数对象类的对象</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j;&#125;; <span class="comment">//lambda</span></span><br></pre></td></tr></table></figure></p>
<p>48.我们不能直接将重载函数的名字存入 function 类型的对象中，因为容易产生二义性，不过我们可以使用存储函数指针或者 lambda 的方式来消除二义性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span> <span class="keyword">int</span>)&gt; binops;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;);      <span class="comment">//错误，究竟是哪个add？</span></span><br><span class="line">===============solution====================</span><br><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">binops.insert(  &#123;<span class="string">"+"</span>, fp&#125; );</span><br><span class="line">binops.insert( &#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> add(a,b);&#125; &#125;);</span><br></pre></td></tr></table></figure></p>
<p>49.新版本标准库重的 function 类与旧版本中的 unary_function 和 binary_function 没有关联，后两个类已经被 bind 函数替代了。</p>
<p>50.转换构造函数和类型转换运算符共同定义了类类型转换，这样的转换有时也会被称作用户定义的类型转换。</p>
<p>51.类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中 type 表示某种类型，类型转换运算符可以面向任意类型(除 void 之外)进行定义，只要该类型能作为函数的返回类型。<br>因此我们不允许转换成数组或者函数类型，但允许转换成指针或引用类型。</p>
<p>52.一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是 const 。</p>
<p>53.尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于标准(内置)类型转换之前或之后，并与其一起使用。</p>
<p>54.因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参。尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值。</p>
<p>55.如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p>
<p>56.为了防止类型转换之后的类型再进行隐式转换， c++ 11 新标准引入了显式的类型转换运算符<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SmallInt</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br><span class="line">si + <span class="number">6</span>;            </span><br><span class="line"><span class="comment">// 错误：此处需要隐式的类型转换，但类的运算符是显式的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (si) + <span class="number">3</span>;  </span><br><span class="line"><span class="comment">//正确：显式地请求类型转换</span></span><br></pre></td></tr></table></figure></p>
<p>57.当表达式出现在下列位置时，显式的类型转换将被隐式地执行</p>
<ul>
<li>if、while及do语句的条件部分</li>
<li>for 语句头的条件表达式</li>
<li>逻辑非运算符（!）、逻辑或运算符（||）、逻辑与运算符（&amp;&amp;）的运算对象</li>
<li>条件运算符（? :）的条件表达式</li>
</ul>
<p>58.向 bool 的类型转换通常用在条件部分，因此 operator bool 一般定义成 explicit。</p>
<p>59.通常情况下，不要为类定义相同得类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型(int 、 double)的转换。</p>
<p>60.当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。</p>
<p>61.类型转换与运算符设计的经验，总的来说：除了显式地向 bool 类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。</p>
<ul>
<li>不要令两个类执行相同的类型转换</li>
<li>避免转换目标是内置算术类型的类型转换。特别是我们已经定义一个转换成算术类型的类型转换。</li>
<li>不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符，则类型转换操作将转换我们的类型的对象，然后使用内置的运算符。</li>
<li>不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作</li>
</ul>
<p>62.如果在调用重载函数时，我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。</p>
<p>63.在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</p>
<p>64.表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数。</p>
<p>65.如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</p>
<h2 id="面向对象程序设计">面向对象程序设计</h2><p>1.面向对象程序设计的核心思想是数据抽象、继承和动态绑定。</p>
<p>2.通过继承联系在一起的类构成的一种层次关系，在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得来的类称为派生类。</p>
<p>3.如果基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Quote</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>4.派生类必须使用类派生列表明确指出它从哪些基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定，即在运行时，根据引用或指针所绑定的对象类型不同，选择不同的函数版本，有可能是基类的版本也有可能是派生类的版本。</p>
<p>6.基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
<p>7.关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。</p>
<p>8.如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<p>9.成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</p>
<p>10.基类中用 protect 运算符修饰的成员只能被基类本身或者派生类访问，但是其他公共对象无法访问。</p>
<p>11.类的派生类列表里，每个基类前面可以有 public protect private 的其中一个。</p>
<p>12.派生类必须重新声明那些继承而来的成员函数中需要覆盖而来的函数。</p>
<p>13.如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，因此我们能将公有派生类类型的对象绑定到基类的引用或指针上。</p>
<p>14.派生类经常(但不总是)覆盖它的继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>15.c++ 11 允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数的 const 关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字 override 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> B </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> D1 : B </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> override</span>;    <span class="comment">//正确：f1 与基类中的 f1 匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> override</span>;          <span class="comment">//错误：B 没有形如 f2(int)的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> override</span>;             <span class="comment">//错误：f3 不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> override</span>;             <span class="comment">//错误：B 没有名为 f4 的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>16.我们能把派生类的对象当成基类对象来使用，而且我们也能将基类指针或引用绑定到派生类对象中的基类部分上，因为派生类对象中含有与其基类对应的组成部分。</p>
<p>17.派生类不能直接初始化从基类继承而来的成员，派生类必须使用基类的构造函数来初始化它的基类部分。</p>
<p>18.派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p>
<p>19.如果我们想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p>
<p>20.如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。</p>
<p>21.派生类的声明与其他类差别不大，声明中包含类名，但是不包含它的派生列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote; <span class="comment">// 错误：派生类列表不能出现在这里</span></span><br><span class="line"><span class="keyword">class</span> Bulk_quote;                <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p>
<p>22.如果我们想将某个类用作基类，则这个类必须已经定义而非仅仅声明，即一个类不能派生它本身。</p>
<p>23.最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<p>24.c++ 11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> D2 : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>;       <span class="comment">//不允许后续的其他类覆盖 f1(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> D3 : D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;                      <span class="comment">//正确：覆盖从间接基类B继承而来的 f2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;             <span class="comment">//错误：D2 已经将 f2 声明成 final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>25.我们可以将基类的指针或引用绑定到派生类对象上，因此当使用基类的指针或者引用时，实际上我们并不清楚该指针或引用所绑定对象的真实类型(动态绑定)。</p>
<p>26.和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内，因为每个派生类对象都包含一个基类部分。</p>
<p>27.当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。</p>
<p>28.表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。</p>
<p>29.不存在从基类向派生类的自动类型转换，因为一个基类的对象可能时派生类对象的一部分。</p>
<p>30.如果在基类中含有一个或多个虚函数，我们可以使用 dynamic_cast 请求一个类型转换，该转换的安全检查将在运行时执行。</p>
<p>31.如果我们已知某个基类向派生类的转换时安全的，则我们可以使用 static_cast 来强制覆盖掉编译器的检查工作。</p>
<p>32.派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。</p>
<p>33.当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类会被忽略掉(切掉、截断)。</p>
<p>34.在具有继承关系的类之间进行类型转换，有三点非常重要：</p>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。</li>
</ul>
<p>35.当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</p>
<p>36.对非虚函数的调用在编译时进行绑定，对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。</p>
<p>37.一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p>38.当派生类覆盖了某个虚函数时。该函数在基类中的形参必须与派生类中的形参严格匹配，当然返回类型也必须与基类函数匹配。</p>
<p>39.如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法行为，编译器将认为新定义的这个函数与基类中原有的函数是相互独立的，派生类的函数并没有覆盖掉基类中的版本。</p>
<p>40.如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。因为如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参；如果实际运行的是派生类中的函数版本也是传入基类函数定义的默认实参。</p>
<p>41.通常只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制，在这种情况下，基类的版本通常完成继承层次种所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></p>
<p>42.如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归(虚函数-&gt;找不到基类对应版本入口-&gt;继续调用虚函数版本……)。</p>
<p>43.如果我们需要让每个派生类都定义它自身的某个属性，那么我们可以将一个虚函数说明为纯为函数。</p>
<p>44.一个纯虚函数域普通虚函数不一样，一个纯虚函数无序定义。我们只要通过在函数体声明语句的分号之前书写 =0 就可以将一个虚函数说明为纯虚函数。其中， =0 只能出现在类内部的虚函数声明语句处。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dis_quote : <span class="keyword">public</span> Quote</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>45.含有或者未竟覆盖直接继承纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口，因此我们不能定义抽象基类的对象。</p>
<p>46.protect 运算符可以看作是 public 和 private 中和的产物：</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li>
<li>和公有成员类似，受保护的成员对于派生类的成员 和 友元(基类的友元)来说是可以访问的。</li>
<li>派生类的成员 或 友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了理解最后一条规则，看一下下面的例子</span></span><br><span class="line"><span class="keyword">class</span> Base </span><br><span class="line">&#123;</span><br><span class="line">protect :</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Sneaky : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    s.j = s.prot_mem = <span class="number">0</span>;   </span><br><span class="line"><span class="comment">// 正确：clobber 能访问 Sneaky 对象的 private 和 protected 成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    b.prot_mem = <span class="number">0</span>;     <span class="comment">// 错误：clobber 不能访问 Base 的 protect 成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>47.派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。</p>
<p>48.某个类对其继承而来的成员的访问权限受到两个因素影响：一是基类中该成员的访问说明符，二是在派生类的派生列表中的说明符。</p>
<p>49.派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于类成员的访问权限，以及控制继承自派生类的新类的访问权限。<br>派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关。<br>一篇有趣的补充博文<a href="https://segmentfault.com/a/1190000002868033" target="_blank" rel="external">传送门</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">protected</span> :</span><br><span class="line">        <span class="keyword">int</span> prot_mem;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="keyword">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> Pub_Dery : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;    <span class="comment">//正确 派生类能访问 protected 成员</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> priv_mem; &#125;   <span class="comment">//错误 派生类不能访问 private 成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Priv_Derv : <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prot_mem;&#125;  </span><br><span class="line">    <span class="comment">// private 不影响派生类的访问权限 prot_mem 是 protected 成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pub_Derv d1;        <span class="comment">//继承自Base的成员是public</span></span><br><span class="line">Priv_Derv d2;       <span class="comment">//继承自Base的成员是private</span></span><br><span class="line">d1.pub_mem();       <span class="comment">//正确：pub_mem 在派生类中是 public</span></span><br><span class="line">d2.pub_mem();       <span class="comment">//错误: pub_mem 在派生类中是 private</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Derived_from_Public : <span class="keyword">public</span> Pub_Derv</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem;&#125; ;  </span><br><span class="line">    <span class="comment">// 正确：Base::prot_mem 在 Pub_Derv 中仍然是 protected</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Derived_from_Private : <span class="keyword">public</span> Priv_Derv</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem ;&#125;; </span><br><span class="line">    <span class="comment">// 错误：Base::prot_mem 在 Priv_Derv 中是 private的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>50.对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可转换的，反之则不行。详见 c++ prime 5th 中文版的 p544。</p>
<p>51.关于类的设计与受保护的成员详见 c++ prime 5th 中文版的p544。</p>
<p>52.我们不能继承友元关系，每个类负责控制各自成员的访问权限。</p>
<p>53.struct 和 class 唯一的差别是 class 关键字定义的派生类默认是私有继承的；而 struct 关键字定义的派生类默认是公有继承的。</p>
<p>54.派生类只能为那些它可以访问的名字提供 using 声明，即收到 public 、 protect 、 private 等关键字的限制。详见 c++ prime　5th 中文版的p546。</p>
<p>55.当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。</p>
<p>56.派生类的成员将隐藏同名的基类成员，因此除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
<p>57.关于名字查找与继承详见 c++ prime 5th 中文版的p549。</p>
<p>58.如果派生类希望所有的重载版本对于它来说都是可见的，那么它需要覆盖所有的版本，或者一个也不覆盖，或者用 using 声明重载的成员。</p>
<p>59.如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数，否则会产生未定义行为。</p>
<p>60.一个基类总是需要析构函数，但是这个析构函数虽然能设定为虚函数，但是不能为空，因为我们无法由此判断该基类还需要赋值运算符或拷贝构造函数。</p>
<p>61.虚析构函数将阻止合成移动操作，如果一个类定义了析构函数，即使它通过 =default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
<p>62.对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</p>
<p>63.关于派生类删除的拷贝控制与基类的关系详见 c++ prime 5th 中文版的 p553。</p>
<p>64.如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</p>
<p>65.大多数基类都会定义一个虚析构函数，在默认情况下，基类不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们的确需要执行移动操作时，应该首先在基类中进行定义。</p>
<p>66.和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源，派生类的析构函数首先执行，然后是基类的析构函数，如此类推，沿着继承体系的反方向直至最后。</p>
<p>67.派生类定义了拷贝和移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p>
<p>68.在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（移动）构造函数</p>
<p>69.当基类的构造函数执行时，该对象的派生类部分是未被初始化的状态。反过来，当执行基类的析构函数时，派生类的部分已经销毁了。在这种情况下，编译器认为对象的类型在构造或者析构的过程中，对象的类和构造(析构)函数的类看作时同一个，就例如虚函数的调用绑定。</p>
<p>70.如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
<p>71.一个类也只继承其直接基类的构造函数，不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>
<p>72.通常情况下，using 声明语句只是令某个名字在当前作用于可见，而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>
<p>73.一个构造函数的 using 声明不会改变在该构造函数的访问级别。例如，基类的私有构造函数在派生类中还是一个私有构造函数。</p>
<p>74.一个 using 声明语句不能指定 explicit 或者 constexpr，如果基类的构造函数时 explicit 或者 constexpr ，则继承的构造函数也拥有同样的属性。</p>
<p>75.当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。<br>例如：如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参），另一个构造函数只接受一个形参，它对应基类中最左侧的没有默认值的那个形参。</p>
<p>76.如果基类含有几个构造函数，大多数时候派生类会继承所有这些构造函数，但是有两个例外：</p>
<ul>
<li>一：派生类可以继承一部分构造函数，而其他构造函数定义自己的版本，如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承，定义在派生类中的构造函数将会替换继承而来的构造函数。</li>
<li>二：默认、拷贝和移动构造函数不会继承，这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，如果一个类只含有继承而来的构造函数，则它也将拥有一个合成的默认构造函数。（初始化派生类的成员）</li>
</ul>
<p>77.当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的是基类的(智能)指针。和往常一样，这些指针所指的对象的动态类型可能是基类类型，也可能是派生类类型。(shared_ptr 支持派生类向基类的类型转换)</p>
<p>78.当我们令一个类公有地继承另一个类时，派生类应该反映与基类的 “is A”的关系，即派生类是基类的某种具现形式。而且公有派生类的对象应该可以用在任何需要基类对象的地方，类似一种包括的关系。类型之间的另一种常见关系就是“has A”，即这种关系的类应该组合成成员。</p>
<h2 id="模板与泛型编程">模板与泛型编程</h2><p>1.模板是 c++ 中 泛型编程的基础，一个模板就是一个创建类或函数的公式。</p>
<p>2.模板定义从关键字 template 开始，后面跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数(template parameter)列表，用小于号(&lt;)和大于号(&gt;) 包围起来。<br>例如，我们可以定义一个函数模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="comment">// 声明了一个 T 的类型参数，表示一个类型，</span></span><br><span class="line"><span class="comment">// T的实际类型在编译时根据 compare 的使用情况来确定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp; v1, <span class="keyword">const</span> T &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.在模板定义中，模板参数列表不能为空，类似地，我们可以显式或隐式的指定模板实参绑定到模板参数上。</p>
<p>4.编译器用推断出的模板参数来生成的函数版本的过程叫作实例化，这些生成出来的函数叫作实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化出 int compare(const int&amp; , const int&amp;)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; endl; <span class="comment">// T 为 int</span></span><br><span class="line"><span class="comment">// 实例化出 int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; compare(vec1 , vec2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>5.在 compare 函数中的 T 就是一个模板类型参数(type parameter)。类型参数前必须使用关键字 class 或 typename 。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。<br>类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量的声明或类型转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">foo</span><span class="params">(T* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T , <span class="keyword">class</span> U&gt; calc (<span class="keyword">const</span> T&amp; , <span class="keyword">const</span> U&amp;);</span><br></pre></td></tr></table></figure></p>
<p>6.我们还可以在模板中定义非类型参数，一个非类型参数表示一个值而不是一个类型，这些值必须是常量表达式。我们通过一个特定的类型名而不是关键字 class 或 typename 来指定非类型变量。</p>
<p>7.一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或左值引用。绑定到非类型整型参数的实参必须是一个常量表达式。<br>绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数可以是 nullptr 或一个值为 0 的常量表达式来实例化。</p>
<p>8.函数模板可以声明为 inline 或 constexpr。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline 说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span> <span class="params">(<span class="keyword">const</span> T&amp; , <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>9.模板程序应该尽量减少对实参类型的要求，模板中的函数参数是 const的引用，函数体中的条件判断尽量仅使用 &lt; 比较运算。</p>
<p>10.当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。<br>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。</p>
<p>11.函数模板和类模板成员函数的<strong>定义</strong>通常放在头文件中，因此与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p>12.模板包含两种名字：</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p>当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。因此，模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。</p>
<p>13.当我们编写模板时，代码不能使针对特定类型的，但模板代码通常对其所使用的类型有一些假设。</p>
<p>14.通常，编译器会在三个阶段报告错误：</p>
<ul>
<li>第一个阶段是编译模板本身时。编译器可以检查语法错误。</li>
<li>第二个阶段是编译器遇到模板使用时，在这个阶段，编译器对于函数模板调用会检查实参数目是否正确，还能检查参数类型是否匹配；对于类模板，编译器可以检查用户是否提供了正确数目的模板实参。</li>
<li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
<p>15.保证传递给模板实参支持模板所要求的操作，以及这些在模板中能正确工作是调用者的责任。</p>
<p>16.一个类模板的每个实例都形成一个独立的类。每个实例之间没有关联，也没有特殊的访问权限。</p>
<p>17.为了阅读模板类代码，我们应该记住类模板的名字不是一个类型名。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。</p>
<p>18.类模板的成员函数本身是一个普通函数，但是类模板的每个实例都有其自己版本的成员函数，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure></p>
<p>19.默认情况下，对于一个已经实例化的类模板，其成员只有在使用时才被实例化。</p>
<p>20.当我们使用一个类模板类型时必须提供模板实参，但如果在类模板自己的作用于中，我们可以直接使用模板命而不提供实参。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> BlobPtr</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ··· <span class="comment">// do something</span></span><br><span class="line">        BlobPtr &amp; <span class="keyword">operator</span>++();</span><br><span class="line">        <span class="comment">// 正确：编译器处理时按照 BlobPtr&lt;T&gt;&amp; operator++();</span></span><br><span class="line">        BlobPtr &amp; <span class="keyword">operator</span>--();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>21.当我们在类模板外定义其成员时，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">**BlobPtr&lt;T&gt;** BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 返回类型在作用域外，必须要指出返回类型是一个实例化的 BlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; </span><br><span class="line">    <span class="comment">// ret 已经在作用域内，不用重复模板实参</span></span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>22.当一个类包含一个友元声明时，类与友元各自是否是模板是相互没有无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例，如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在将模板的一个特定实例声明为友元时要先前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Pal;</span><br><span class="line"><span class="keyword">class</span> c</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用类 C 实例化的Pal是C的一个友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;C&gt;;</span><br><span class="line">    <span class="comment">//Pal2 的所有实例都是 C 的友元，这种情况无需前置声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> vec2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// C2 的每个实例将相同实例化的 Pal 运算符一般被声明为友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;T&gt;; <span class="comment">// 一对一</span></span><br><span class="line">    <span class="comment">// Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ***X***&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2; <span class="comment">// 多对多</span></span><br><span class="line">    <span class="comment">// Pal3 是一个非模板类，它是 C2 所有实例的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Pal3;    <span class="comment">// 多对一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数</span></span><br></pre></td></tr></table></figure></p>
<p>23.在新标准中，我们可以将模板类型参数声明为友元：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tyepe&gt; <span class="keyword">class</span> Bar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> Type; <span class="comment">// 将访问权限授予用来实例化 Bar 的类型</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>24.类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个别名。一个模板类型别名时一族类的别名。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T,T&gt;;</span><br><span class="line"><span class="comment">// authors 是一个 pair&lt;string,string&gt;</span></span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors;</span><br></pre></td></tr></table></figure></p>
<p>25.我们定义一个模板类型别名时，可以固定一个或多个模板参数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo </span><br><span class="line">partNO&lt;<span class="built_in">string</span>&gt; books; <span class="comment">// books 是一个 pair&lt;string,unsigned&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>26.与任何其他类相同，类模板可以声明 static 成员，与任何其他 static 数据成员相同，模板类的每个 static 数据成员必须有且仅有一个定义。但是，类的模板的每个实例都有一个独有的 static 对象。这时，我们可以将 static 数据成员也定义成模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>27.类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化。当然，在我们通过类类直接访问 static 成员，我们必须引用一个特定的实例。</p>
<p>28.类似函数参数的名字，一个模板参数的名字也没有什么内在的含义。我们通常将类型参数命名为 T，但实际上我们可以使用任何名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名。所以一个模板参数名在一个特定模板参数列表中只能出现一次。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> doubleA;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A,<span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    A tmp = a;</span><br><span class="line">    <span class="keyword">double</span> B; <span class="comment">// 错误：重声明模板参数 B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>29.一个特定文件所需要的模板声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。模板声明必须包含模板参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob;</span><br></pre></td></tr></table></figure></p>
<p>30.默认情况下，c++ 假定通过作用域运算符访问的名字不是类型，而是成员。<br>如果我们希望通知编译器一个名字表示类型时，必须使用关键字 typename ，而不能使用class。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">***<span class="keyword">typename</span>*** ***T::<span class="keyword">value_t</span>ype*** top(<span class="keyword">const</span> T&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::<span class="keyword">value_t</span>ype();      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>31.我们可以给函数和类模板提供默认实参，与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare 有一个默认模板实参 less&lt;T&gt; 和一个默认函数实参 F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare &lt;<span class="keyword">typename</span> T &amp;v1 , <span class="keyword">typename</span> T &amp;v2, F f = F()&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f(v1,v2)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f(v2,v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>32.如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keyword">int</span>&gt; <span class="keyword">class</span> Numbers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Numbers(T v = ) : val(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T val;</span><br><span class="line">&#125;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;  <span class="comment">// 使用默认类型</span></span><br></pre></td></tr></table></figure></p>
<p>33.一个类无论是普通类还是类模板，可以包含本身是模板的成员函数。这种成员被成为成员模板。成员模板不能是虚函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> DebugDelete</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>) : os(s) &#123;&#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T *p)</span> <span class="keyword">const</span></span><br><span class="line">        </span>&#123;os &lt;&lt; <span class="string">"delete unique_ptr"</span> &lt;&lt; <span class="built_in">std</span>::endl; <span class="keyword">delete</span> p;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>34.与类模板的普通函数成员不同，当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="comment">// 构造函数的类型参数</span></span><br><span class="line">    Blob&lt;T&gt;::Blob(It b, It e) :</span><br><span class="line">        data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b,e)) &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>35.当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。<br>当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。<br>在多个文件中实例化相同的模板的额外开销可能非常严重，在新标准中，我们可以通过显式实例化来避免这种开销。<br>显式实例化的形式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">extern</span> declaration;  <span class="comment">// 实例化定义</span></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> Blob&lt;<span class="built_in">string</span>&gt;; <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, cons <span class="keyword">int</span>&amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></p>
<p>36.当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。因为在程序的其他位置有该实例化的一个非 extern 声明(定义)。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。由于编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//application.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> Blob&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line">Blob&lt;<span class="built_in">string</span>&gt; sa1.sa2; <span class="comment">// 实例化会出现在其他地方</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a2(a1);</span><br><span class="line"><span class="keyword">int</span> i = compare(a1[<span class="number">0</span>],a2[<span class="number">0</span>]); <span class="comment">//实例化会出现在其他地方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> Blob&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>37.对于每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</p>
<p>38.在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数，包括内联的成员函数。</p>
<p>39.shared_ptr 和 unique_ptr 一个重要的差异是它们管理所保存的指针策略：前者给予我们共享指针所有权的能力，后者则独占指针。另一个差异是两者允许用户重载默认删除器的方式：前者的删除器类型是运行时确定的，所以可以随时通过使用一种类型的删除器构造一个 shared_ptr，随后使用 reset 赋予这个 shared_ptr 另一个类型的删除器。后者的删除器是编译时确定的，删除器的类型是类类型的一部分，这样删除器可以直接保存在 unique_ptr 对象中，避免了间接调用删除器运行时开销。</p>
<p>40.在其他类型转换中，能在调用中应用于函数模板的包括如下两项：</p>
<ul>
<li>const 转换：可以将一个非 const 对象的引用传递给一个 const 的引用(或指针)形参。</li>
<li>数组或函数指针转换： 如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</li>
</ul>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
<p>41.一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。</p>
<p>42.如果函数实参类型不是模板参数，则对实参进行正常的类型转换。</p>
<p>43.在某些情况下，编译器无法推断出模板实参的类型，或者我们希望用户控制模板实例化。这个时候我们希望调用者提供一个显式模板实参。</p>
<p>44.我们提供显式模板实参的方式与定义类模板实例的方式相同，显式模板实参在尖括号中给出，位于函数名之后，实参列表之前。显示模板实参按由左到右的顺序与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依次类推。只有尾部(最右)参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数中推断出来。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2,T3)</span></span>;</span><br><span class="line"><span class="comment">//T1 是显式指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i,lng); <span class="comment">//long long sum(int,long)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2,T1)</span></span>;</span><br><span class="line"><span class="comment">//错误：不断推断T3的类型</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i,lng);</span><br><span class="line"><span class="comment">//正确：显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>,<span class="keyword">long</span>&gt;(i,lng);</span><br></pre></td></tr></table></figure></p>
<p>45.对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#22914;&#26524;&#19981;&#20808;&#23454;&#20363;&#21270;&#19968;&#20010;&#29305;&#23450;&#27169;&#26495;&#65292;&#37027;&#20040;&#25512;&#27979;&#20004;&#20010;&#21442;&#25968;&#31867;&#22411;&#19968;&#33268;&#10;long lng;&#10;compare(lng,1024);&#10;compare&#60;long&#62;(lng,1024);&#10;compare&#60;int&#62;(lng,1024);&#10;// &#31532;&#19968;&#20010;&#35843;&#29992;&#22240;&#20026;&#20256;&#36882;&#32473; compare &#30340;&#23454;&#21442;&#24517;&#39035;&#20855;&#26377;&#30456;&#21516;&#30340;&#31867;&#22411;&#10;// &#22914;&#26524;&#25105;&#20204;&#26174;&#24335;&#25351;&#23450;&#27169;&#26495;&#31867;&#22411;&#21442;&#25968;&#65292;&#23601;&#21487;&#20197;&#36827;&#34892;&#27491;&#24120;&#31867;&#22411;&#36716;&#25442;&#20102;</span><br></pre></td></tr></table></figure></p>
<p>46.当我们不知道模板函数返回结果的准确类型，但是知道所需类型是所处理的序列的元素类型时，可以使用尾置返回类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是 int 序列，则返回类型是 int&amp;</span></span><br></pre></td></tr></table></figure></p>
<p>47.当我们无法直接获得所需要的类型时，可以使用标准库的类型转换模板，详见 c++ prime 中文版 5th的p606。</p>
<p>48.当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</p>
<p>49.当参数时一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值。例如通过使用显式模板实参来消除函数的二义性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// T的模板类型为 int</span></span><br><span class="line"><span class="keyword">int</span> (*pf1) (<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br><span class="line"><span class="comment">//func 的重载版本，每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span>)</span>;</span><br><span class="line">func(compare);<span class="comment">// 错误：二义性</span></span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;) <span class="comment">//正确：使用 int 版本</span></span><br></pre></td></tr></table></figure></p>
<p>50.当一个函数参数是模板类型参数的一个普通(左值)引用时(即，形如 T&amp;)，绑定规则告诉我们，只能传递给它一个左值(如，一个变量或一个返回引用类型的表达式)。<br>实参可以是 const 类型，也可以不是。如果实参是 const ，则 T 将被推断为 const 类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>; <span class="comment">// 实参必须是个左值</span></span><br><span class="line"><span class="comment">// i 是一个 int,模板参数类型 T 是 int</span></span><br><span class="line">f1(i);</span><br><span class="line"><span class="comment">// ci 是一个 const Int,模板参数 T 是 const int</span></span><br><span class="line">f1(ci);</span><br><span class="line"><span class="comment">//错误： 传递给一个 &amp; 参数必须是一个左值</span></span><br><span class="line">f1(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>51.如果一个函数参数类型是 const T&amp;,我们可以传递给它任何类型的实参：一个对象(const 或 非const)、一个临时对象或是一个字面常量值。当函数参数本身是 const 时，T的类型推断的结果不会是一个 const 类型，因为 const 已经是函数参数类型的一部分。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span> <span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2 中的参数是 const &amp;，实参中的 const 是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数参数都被推断为 const int&amp;</span></span><br><span class="line"><span class="comment">// i 是一个 int，模板参数 T 是 int</span></span><br><span class="line"><span class="title">f2</span><span class="params">(i)</span></span>;</span><br><span class="line"><span class="comment">// ci 是一个 const int，但模板参数 T 是 int</span></span><br><span class="line">f2(ci);</span><br><span class="line"><span class="comment">// 一个 const &amp;参数可以绑定到一个右值，T 是 int</span></span><br><span class="line">f2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>52.当一个函数参数是一个右值引用(即，形如 T&amp;&amp;)时，我们可以传递给它一个右值。这样的类型推断过程类似普通左值引用函数参数的推断过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span><br><span class="line"><span class="comment">// 实参时一个 int 类型的右值，模板参数 T 是 int</span></span><br><span class="line"><span class="title">f3</span><span class="params">(42)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>53.在绑定规则中有两个例外</p>
<ul>
<li>第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值(i)传递给函数的右值引用参数，且此右值引用指向模板类型参数(如 T&amp;&amp;)，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用f3(i)时，编译器推断 T 的类型为 int&amp;，而非 int。</li>
<li>第二个例外是：如果我们间接创建一个引用的引用，则这些引用会形成折叠。引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。<ul>
<li>X&amp; &amp;、X&amp; &amp;&amp; 和 X&amp;&amp; &amp;都折叠成类型 X&amp;</li>
<li>类型 X&amp;&amp; &amp;&amp;折叠成 X&amp;&amp;</li>
</ul>
</li>
</ul>
<p>54.如果一个函数参数是指向模板参数类型的右值引用(如，T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T &amp;)。</p>
<p>55.在实际中，右值引用通常用于两种情况：模板转发实参或模板被重载。</p>
<p>56.使用右值引用的函数模板通常是用以下方式重载的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>57.我们可以用 std::move 将一个右值引用绑定到左值上。详见 c++ prime 中文版5th 的p611。</p>
<p>58.虽然不能隐式地将一个左值转换为右值引用，但我们可以用 static_cast 显式地将一个左值转换为一个右值引用，<br>对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们<strong>截断</strong>左值。但是这种做法不利于我们找到潜在的截断左值的代码。</p>
<p>59.某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是 const 的以及实参是左值还是右值。</p>
<p>60.如果一个函数参数是指向模板类型参数的右值引用(如 T&amp;&amp;)，它对应的实参的 const 属性和左值 / 右值属性得到保持。</p>
<p>61.我们可以使用一个名为 std::forward 的新标准库设置来转发参数，它能保持原始实参的类型，类似move，forward 定义在头文件 utility 中。与 move 不同，forward 必须通过显式模板实参来调用。forward 返回该显式实参类型的右值引用。即 T&amp;&amp;。</p>
<p>62.通常情况下，我们使用 forward 传递哪些定义为模板类型参数的右值引用的函数参数。通过返回类型上的引用折叠,forward 可以保持给定实参的左值或右值属性。</p>
<p>63.当用于一个指向模板参数类型的右值引用函数参数(T &amp;&amp;)时，forward 会保护实参类型的所有细节。</p>
<p>64.函数模板的匹配规则会收到以下方面影响：</p>
<ul>
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li>
<li>候选的函数模板总是可以行的，因为模板实参推断会排除任何不可行的模板。</li>
<li>与往常一样，可行函数(模板与非模板)按类型转换(如果对此调用需要的话)来排序。当然，函数模板调用的类型转换是有限的。</li>
<li><p>如果恰好有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是，如果有多个函数提供同样好的匹配，则：</p>
<pre><code>-<span class="ruby"> 如果同样好的函数中只有一个是非模板函数，则选择此函数。
</span>-<span class="ruby"> 如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板
</span>-<span class="ruby"> 否则，此调用有歧义。</span>
</code></pre></li>
</ul>
<p>65.正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的实参类型转换有深刻理解。</p>
<p>66.在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p>
<p>67.一个可变参数模板就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包。存在两种参数包：模板参数包，表示零个或多个模板参数；函数参数包，表示零个或多个函数参数。</p>
<p>68.我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表；<br>一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Args 是一个模板参数包，</span></span><br><span class="line"><span class="comment">//rest 是一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。</span></span><br><span class="line"><span class="comment">//在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。</span></span><br><span class="line"><span class="comment">//Args 表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">//rest 表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t,<span class="keyword">const</span> Args... rest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line">foo(i,s,<span class="number">42</span>,d);</span><br><span class="line"><span class="comment">// void foo(const int&amp;,const string&amp;,const int&amp;,const double&amp;);</span></span><br><span class="line">foo(s,<span class="number">42</span>,<span class="string">"hi"</span>);</span><br><span class="line"><span class="comment">// void foo(const string&amp;, const int&amp;,const char[3]);</span></span><br><span class="line">foo(d,s);</span><br><span class="line"><span class="comment">// void foo(const double&amp;,const string&amp;);</span></span><br><span class="line">foo(<span class="string">"hi"</span>);</span><br><span class="line"><span class="comment">// void foo(const char[3]&amp;);</span></span><br></pre></td></tr></table></figure></p>
<p>69.当我们需要直到包中有多少元素时，可以使用 sizeof… 运算符，类似 sizeof ，sizeof… 也返回一个常量表达式，而且不会对实参求值。</p>
<p>70.可变参数函数通常时递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自己。<br>因此，当定义可变参数版本的 print 时，非可变参数版本的声明必须在作用域中，否则可变参数版本会无限递归。</p>
<p>71.对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展。当扩展一个包时，我们还要提供用于每个扩展元素的模式，该模式将会应用于包中每个元素。</p>
<p>72.关于转发参数包详见 c++ prime 5th 中文版的p624。</p>
<p>73.在某些模板的定义对特定类型时不适合的：通用定义可能编译失败或做的不好。当我们不能使用模板版本时，可以定义类或函数模板的一个特例化版本。  一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应该使用关键 template 后跟一个空尖括号对 &lt;&gt; ，来指出我们将为原模板的所有模板参数提供实参：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1,<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>74.特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。</p>
<p>75.为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中。模板及其特例化版本应该声明在同一个头文件中。所有同名版本的声明放在前面，然后是这些模板的特例化版本。</p>
<p>76.我们只能部分特例化类模板，而不能部分特例化函数模板。一个类模板的部分特例化本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<p>77.我们可以只特例化特定成员函数而不是特例化整个模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> Foo </span><br><span class="line">&#123;</span><br><span class="line">    Foo(<span class="keyword">const</span> T &amp;t = T()) : mem(t) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    T mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs;</span><br><span class="line"><span class="comment">// 实例化Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar();</span><br><span class="line"><span class="comment">// 实例化Foo&lt;string&gt;::Bar</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;</span><br><span class="line"><span class="comment">//实例化Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar();</span><br><span class="line"><span class="comment">// 调用特例化版本 Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//当我们用 int 之外的任何类型使用 Foo 时，其成员像往常一样进行实例化</span></span><br><span class="line"><span class="comment">//当我们用 int 使用 Foo 时，Bar 之外的成员像往前一样进行实例化。</span></span><br><span class="line"><span class="comment">//如果我们使用 Foo&lt;int&gt;的成员 Bar ，则会使用我们定义的特例化版本</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时候，我在写代码的时候忘记了一些概念，就会回头看看我之前写的东西。但是我发现有些概念好像还是很模糊，而且也有点偏颇，不是十分完整，如果您看到还理解的话，建议您去 MSDN 找相应的文档看看。<br>]]>
    
    </summary>
    
      <category term="c++" scheme="https://luengzeegin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Note in c++ prime 5th (chap8-12)]]></title>
    <link href="https://luengzeegin.github.io/2016/07/24/cpp-prime-chap-8-12/"/>
    <id>https://luengzeegin.github.io/2016/07/24/cpp-prime-chap-8-12/</id>
    <published>2016-07-24T09:35:44.000Z</published>
    <updated>2017-02-15T12:00:39.281Z</updated>
    <content type="html"><![CDATA[<h2 id="IO类">IO类</h2><p>1.宽字符版本的类型和函数的名字以一个w开始。</p>
<p>2.我们不能将形参或返回类型设置为流类型， 进行io操作的函数以引用方式传递和返回流。</p>
<p>3.确定一个流对象的状态的最简单的方法是将它当作 一个条件来使用： while(cin &gt;&gt; word) 如果流状态正常那么循环继续。</p>
<a id="more"></a>
<p>4.流对象的成员clear是重载的，不接受参数的版本清除所有错误标志位，带参数的版本接受一个iostate值，表示流的新状态。<br>例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.clear(<span class="built_in">cin</span>.rastate() &amp; ~<span class="built_in">cin</span>.failbit &amp; ~<span class="built_in">cin</span>.badbit);</span><br><span class="line"><span class="comment">// 首先先用rastate读出当前条件的状态</span></span><br><span class="line"><span class="comment">// 将failbit、badbit 复位 eofbit不变</span></span><br></pre></td></tr></table></figure>
<p>5.io库类型和头文件，详见c++ prime 5th 中文版的278页。</p>
<p>6.io库的条件状态，详见c++ prime 5th 中文版的279页。</p>
<p>7.io库定义了4个iostate的constexpr的值来表示 特定的io条件，详见 c++ prime 5th 中文版的280页。</p>
<p>8.判断io 类stirng流各种字符的类型，详见c++ prime 5th 中文版的82页。</p>
<h2 id="输出缓冲">输出缓冲</h2><p>1.flush 刷新缓冲区，不附加任何字符。</p>
<p>2.endl 输出一个换行然后刷新缓冲区。</p>
<p>3.ends 输出一个空字符，然后刷新缓冲区。</p>
<p>4.如果想每次输出操作之后都进行一个flush操作， 可以使用unitbuf操纵符，它让流对象每次写操作之后 都进行一次flush，而对应的 nounitbuf 操纵符则恢复流的正常缓冲区管理机制。值得一提的是 cerr 默认是设置untibuf。</p>
<p>例 ： cout &lt;&lt; unitbuf；</p>
<p>5.当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。因为实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印。</p>
<p>6.关联的输入流和输出流，在读操作之前，用户提示的信息都会被打印出来。</p>
<p>7.我们使用io类里面的 tie 成员来关联输入流和输出流，tie 是个重载的对象，不带参数的版本，如果该对象关联到输出流那么返回这个流的指针，如果没有关联到流那么返回空指针。带参数的版本接受一个ostream对象的指针，将调用的对象绑定这个ostream对象。<br>例 ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>) <span class="comment">// 使cin绑定cerr</span></span><br><span class="line">ostream *<span class="keyword">old_t</span>ie = <span class="built_in">cin</span>.tie() ; <span class="comment">//返回cout的指针</span></span><br><span class="line">iostream test;</span><br><span class="line">test.tie(<span class="keyword">old_t</span>ie); <span class="comment">// test与cout联系。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="文件流对象">文件流对象</h2><p>1.当一个fstream类对象离开其作用域，与之关联的文件会自动关闭，(每次循环内就是一个作用域?)。</p>
<p>2.open成员函数用于把一个空的文件流对象和文件关联起来，同理close则是关闭关联的流对象。</p>
<p>3.当一个fstream对象被销毁时，close会自动被调用。</p>
<p>4.检验调用open是否成功，可以类比cin if(open)。</p>
<h2 id="文件模式">文件模式</h2><p>1.trunc模式截断文件，如果需要保留内容 则需显示声明app模式。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">app</span> <span class="params">("file", ofstream::app)</span></span>;  </span><br><span class="line">	<span class="comment">// 隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span> <span class="params">("file", ofstream::out | ofstream::app)</span></span>;</span><br><span class="line">	<span class="comment">// 显式表示为输出模式</span></span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">("file")</span>  </span><br><span class="line">	<span class="comment">// file中的文件会被清空，因为这样隐式声明模式是trunc；</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="string流">string流</h2><p>1.stringstrean 特有的操作， 不过这些操作不能对 其他IO类使用。详见c++ prime 5th 中文版的287页。</p>
<p>2.若一个istringstream对象 record 与一个文本行 data 绑定(drew 973555),这样这个 istringstream 对象 可以使用 ‘&gt;&gt;’ 读取这个文本行中的每个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">People info；</span><br><span class="line">record &gt;&gt; info.name； <span class="comment">// 把drew存入name中</span></span><br><span class="line">record &gt;&gt; info.phone； </span><br><span class="line"><span class="comment">// 把drew后面的数字存在phone中istringstream的这个操作 &gt;&gt; 以空格为分隔符。</span></span><br></pre></td></tr></table></figure>
<p>3.当我们需要构造输出，在程序最后一起打印的时候，ostringstream是十分有用的。</p>
<h2 id="顺序容器">顺序容器</h2><p>1.容器在访问和增添方向都有不同性能的差别。详见 c++ prime 5th 中文版的282-293页。</p>
<p>2.如果不确定使用什么顺序容器的话，那么可以在程序中只使用vector和list，因为这两个顺序容器都能使用迭代器，不使用下标操作，避免随机访问。</p>
<p>3.古代的编译器可能需要在两个尖括号之间键入空格。<br>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;空格&gt;</span><br></pre></td></tr></table></figure></p>
<p>4.顺序容器在类类型为元素时，如果这个类没有构造函数那么，我们是可以定义一个保存这个类型的对象的容器，不过如果要传递一个值让它初始化的话，那么需要这个类自身有构造函数。</p>
<p>5.容器库的操作详见 c++ prime 5th 中文版的295页。</p>
<p>6.容器的定义和初始化详见 c++ prime 5th 中文版的299页。</p>
<p>7.容器的赋值运算详见 c++ prime 6=5th 中文版的302页。</p>
<p>8.如果我们要将一个容器初始化为另一个容器的拷贝的时候，两个容器的容器类型和元素类型都必须相同。</p>
<p>9.使用迭代器拷贝一个容器的子序列的时候，可以用一个迭代器代表容器里面的某一个元素。<br>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; authList(authors.begin(), it);</span><br><span class="line"><span class="comment">// 拷贝元素直到(但是不包括) 迭代器it指向的元素。</span></span><br></pre></td></tr></table></figure>
<p>10.如果容器的元素是内置类型或者是具有默认构造函数的类类型的时候，可以只为构造函数提供一个容器大小的参数，如果没有默认构造函数，那么我们还需要提供一个显式的初始值。</p>
<p>11.只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p>
<p>12.使用array类型，我们需要同时指定元素类型和大小。</p>
<p>13.如果两个容器原来大小不一致，赋值后两者的大小都与右边容器的大小一致。</p>
<p>14.array 赋值的时候左右两边运算对象类型要一致，同时array也不允许用花括号包围的值列表进行赋值。</p>
<p>15.assign成员函数，不能用自身的元素替换自身的元素。</p>
<p>16.swap 不仅比拷贝速度快，而且还不会导致指向容器的迭代器引用和指针和失效(容器类型为array和 string的情况除外)。</p>
<p>17.一般的，swap不交换元素，而是交换两个容器的内部的数据结构，不过array不一样，swap会真正交换array中的元素。因此对于array来说，在swap之后指针、引用和迭代器绑定的元素位置不变，但是元素值已经交换了。</p>
<p>18.向顺序容器添加元素的操作详见 c++ prime 5th 中文版的305页。</p>
<p>19.向一个vector、string、deque插入元素会使所有指向容器的迭代器、引用和指针失效。</p>
<p>20.当我们用一个对象初始化或插入一个容器的时候，实际上放入容器中的是对象值的拷贝。</p>
<p>21.insert 返回第一个新加入元素的迭代器，如果范围为空，不插入任何元素，insert会将第一个参数返回，同时不能将自身元素插入到对象里。</p>
<p>22.emplace 函数在容器管理的内存中直接构造函数，传递给 emplace 函数的参数必须与元素类型的构造函数相匹配。与<br>emplace_back 不一样的是 push_back 会创建一个局部临时对象，并将其压入容器中。</p>
<p>23.顺序容器中访问元素的操作，详见 c++ prime 5th 中文版的310页。需要注意的是，这些函数返回的都是引用。</p>
<p>24.如果我们希望确保下标是合法的，可是使用 at 成员函数，如果下标越界，at 会抛出一个 out_of_range 异常。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec[<span class="number">0</span>];	<span class="comment">// 运行错误</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.at(<span class="number">0</span>);  <span class="comment">// 抛出一个out_of_range</span></span><br></pre></td></tr></table></figure></p>
<p>25.顺序容器的删除操作详见 c++ prime 5th 中文版的311页。</p>
<p>26.forward_list 中插入或删除元素的操作详见 c++ prime 5th 中文版的313页。</p>
<p>27.forward_list 定义了 before_begin 首前迭代器，这个迭代器允许在链表首元素之前添加或删除元素。</p>
<p>28.顺序容器的大小操作详见 c++ prime 5th 中文版的314页。</p>
<p>29.array 并不支持 resize。</p>
<p>30.在我们删除元素之后，尾后迭代器总是失效，当我们每次改变容器操作之后都应该重新定位迭代器。</p>
<p>31.容器大小的管理操作详见 c++ prime 5th 中文版的318页。</p>
<p>32.reserve 并不改变容器中元素的数量，它仅影响容器预先分配多大的内存，当需求大小小于或等于当前容量，reserve 什么也不做，容器不会退会内存空间。</p>
<p>31.容器的size是指已经保存的元素的数目。</p>
<p>32.capacity 则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p>
<h2 id="迭代器">迭代器</h2><p>1.迭代器都是通过 * 来实现容器元素操作的。</p>
<p>2.迭代器的范围是一个 [begin,end),end 指向的位置是容器最后一个元素的后一个位置。</p>
<p>3.我们可以反复递增begin来达到end，但是 end 不在begin前面。</p>
<p>4.迭代器有一个c开头的成员用来返回const的迭代器还有一个 r 开头的成员返回反转迭代器。</p>
<p>5.当不需要写操作的时候，应使用 cbegin 和 cend。</p>
<p>6.迭代器类型详见 c++ prime 5th 中文版的365页。</p>
<p>7.插入迭代器的操作与类型详见 c++ prime 5th 中文版的358页。</p>
<p>8.iostream 迭代器的操作详见 c++ prime 5th 中文版的359页。</p>
<p>9.反向迭代器的操作详见 c++ prime 5th 中文版的363页。</p>
<p>10.front_insert 与inserter 的区别在于，front_insert 始终插入容器的第一个元素之前，而 inserter 则是在插入操作完成之后迭代器还会递增指向原来的元素。</p>
<p>11.iostream 迭代器将它们对应的流当作一个特定类型的元素序列来处理，所以这类迭代器要指定读写对象类型。<br>例1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_it(<span class="built_in">cin</span>);  		<span class="comment">// 从 cin 读取 int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;	  				<span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">("afile")</span></span>;					  	<span class="comment">// 文件流迭代器</span></span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; str_it(in);  </span><br><span class="line"><span class="comment">// 从" afile" 读取字符串</span></span><br></pre></td></tr></table></figure></p>
<p>例2：从标准输入读取数据，存入一个vector<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_it(<span class="built_in">cin</span>);  		<span class="comment">// 从 cin 读取 int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;	  				<span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span> (int_it != eof);</span><br><span class="line">	vec.push_back(*in_iter++);</span><br></pre></td></tr></table></figure></p>
<p>12.标准库中迭代器的实现保证在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成。</p>
<p>13.不允许空的或尾后位置的 ostream_iterator。</p>
<p>14.反向迭代器的目的是表示元素范围，而这些范围是不对称的，是一个左开右闭的区域，因此普通迭代器和反向迭代器指向的区域是相邻的位置，而不是相同的位置。详见 c++ prime 5th 中文版的363页和364页的示意图。</p>
<h2 id="容器适配器">容器适配器</h2><p>1.所有容器适配器都支持的操作和类型详见 c++ prime 5th 中文版的329和330页。</p>
<p>2.array 、forward_list 不适用于任何适配器。</p>
<p>3.vector 不适用于 queue。</p>
<p>4.list 不适用于priority_queue。</p>
<p>5.每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，但是我们只可以使用适配器的操作，而不能使用底层容器的操作。<br>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intStack.push(ix); <span class="comment">// intStack 保存0 到 9</span></span><br></pre></td></tr></table></figure></p>
<p>虽然stack 是基于deque实现的，但我们不能直接使用deque操作，意思是不能在stack上调用 push_back 而是调用 stack 自己的 push 操作。</p>
<p>6.priority_queue允许我们在队列中建立优先级，新加入的元素会排在所有优先级比它低的已有元素之前。意思是可以在队列中创建VIP元素，调整这个元素在队列中的位置。</p>
<h2 id="泛型算法">泛型算法</h2><p>1.算法依赖元素类型的操作，但是不依赖容器。</p>
<p>2.算法本身不执行容器的操作。</p>
<p>3.算法不会改变底层容器的大小。</p>
<p>4.算法可能改变元素的值，但是不会直接删除或添加元素。</p>
<p>5.用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。</p>
<p>6.算法形式基本模式 alg(beg , end , dest)  // dest -&gt; destination  即 范围 + 目标</p>
<p>7.只接受单独的 beg2 不接受 end2 的算法假定从 beg2 开始的范围，与 beg 和 end 所表示的范围至少一样大。</p>
<p>8.一个算法如果提供一个额外目的的增值版本，那么在它的新名字应该是原有的算法加上下划线和目的。</p>
<p>9.对于 list 和 forward_list 应该优先使用成员函数版本的算法而不是通用算法。详见c++ prime 5th 中文版的369页。</p>
<p>10.链表特有的操作会改变容器。</p>
<p>11.链表特有的 splice 算法详见c++ prime 5th 中文版的370页. // 将一个链表剪切到另一个链表</p>
<h2 id="lambda_表达式">lambda 表达式</h2><p>1.lambda必须使用尾置返回，同时可以忽略参数列表和返回列表，但是必须包含捕获列表和函数体。</p>
<p>2.如果函数体只是一个return 语句，则返回类型从返回的表达式的类型推断而来，如果函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void。</p>
<p>3.捕获列表只能用局部非 static 变量，不过lambda 可以使用局部 static 变量和在它所在函数之外声明的名字。</p>
<p>4.一个 lambda 捕获的生存期是从 lambda 定义处的代码执行时到 lambda 自身执行的这段时间。</p>
<p>5.与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝。</p>
<p>6.一般来说，我们应该尽量减少捕获的数据量，以及应该避免捕获指针和引用。</p>
<p>7.当我们混合使用隐式捕获和显示捕获的时候，捕获列表中第一个元素必须是一个 &amp; ( 引用 ) 或 = ( 值 ) ，而且显示捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是 &amp; ，则显示捕获必须使用值方式。关于 lambda 捕获列表详见 c++ prime 5th中文版的352页。</p>
<p>8.如果 lambda 捕获列表为空，通常可以用函数来代替它。</p>
<h2 id="可变_lambda">可变 lambda</h2><p>1.如果我们需要改变一个值捕获的变量，那么可以在参数列表后加上关键字 mutable ，这样以后这样就能改变拷贝后变量的值。</p>
<h2 id="bind函数">bind函数</h2><p>1.调用 bind 函数的一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind (callable , arg_list);</span><br><span class="line"><span class="comment">//newCallable 是新生成的可调用对象，callable 旧调用对象 ， arg_list参数列表。</span></span><br><span class="line"><span class="comment">//每次调用newCallable时，newCallable 会调用 callable 并将arg_list作为参数传递过去。</span></span><br></pre></td></tr></table></figure>
<p>2.arg_list中使用占位符表示传递给 newCallable 的参数的位置，例：”_1” 是newCallable第一个参数，此外，占位符都在 placeholders 的命名空间里面所以在使用占位符时需要使用 using namesp std::placeholders<br>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(word.begin() , word.end(),isShorter);  <span class="comment">// 按单词长度由短至长排序</span></span><br><span class="line">sort(word.begin() , word.end(),bind(isShorter, _2,_1); <span class="comment">// 按单词长度由长至短排序</span></span><br><span class="line"><span class="comment">//传入同样的参数，实现相反的功能。</span></span><br></pre></td></tr></table></figure>
<p>3.bind 不能直接用代替对 ostream 的捕获，因为 bind 要拷贝参数，但是 ostream 不能被拷贝，如果传递 ostream 对象，但是又不能拷贝那么就要使用 ref 函数。如果要传递一个常量，但是又不能拷贝，那么使用 cref 函数。</p>
<h2 id="关联容器">关联容器</h2><p>1.标准库中的8个关联容器从三个方面划分：</p>
<ul>
<li>①每个都是基于一个 map 或者一个 set，</li>
<li>②有无重复的关键字以 multi 区分，</li>
<li>③关键字之间有无顺序以 unordered 区分</li>
</ul>
<p>2.类型 map 和 multimap 定义在头文件 map 中，set 和 multimap 定义在头文件 set 中，无序容器则定义在头文件 unordered_map 和 unorder_set中。详见 c++ prime 5th中文版的374页。</p>
<p>3.从 map 提取一个元素中，会得到一个 pair 类型的对象，pair 类型的对象有两个 public 的成员，一个是 first 存储关键字，另一个是 second 存储值。关于 pair 的操作详见 c++ prime 5th中文版的380页。</p>
<p>4.当初始化一个 map 时 ， 必须提供关键字类型和值类型。我们将每个关键字 - 值对包围在花括号中。<br>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; authors = &#123;&#123;<span class="string">"Joyce"</span> , <span class="string">"James"</span>&#125; , &#123;<span class="string">"Austen"</span> , <span class="string">"Jane"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>5.自定义类类类型的有序容器关键字类型的要求详见 c++ prime 5th中文版的378页。</p>
<p>6.创建pair对象<br>        例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;foo ( <span class="string">"John"</span> , <span class="number">16</span>);</span><br><span class="line"><span class="keyword">auto</span> foo = make_pair(<span class="string">"John"</span> , <span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<p>7.关联容器额外的类型别名详见 c++ prime 5th中文版的381页。</p>
<p>8.map 的 value_type 是一个 pair 的，同时 pair 的关键字部分是 const 的 ，因此不能改变元素的关键字。不过可以改变 pair 的值( second 成员)。</p>
<p>9.虽然 set 类型同时定义了 iterator 和 const_iterator，但这两种类型都只允许只读访问 set 中的元素。</p>
<p>10.我们通常不对关联容器使用泛型算法，但是如果真的要使用，要么将它当作一个源序列，要么当作一个目的位置。</p>
<p>11.在无序容器中插入一个容器已存在的元素，那么这个元素并不会对容器产生影响。</p>
<p>12.关联容器的 insert 操作详见 c++ prime 5th中文版的384页。</p>
<p>13.添加单一元素的 insert 和 emplace 版本返回一个 pair ， first 成员是一个指向给定关键字的元素的 pair 的迭代器，second 成员则是一个 bool 值，指出元素是否插入成功。</p>
<p>14.对于允许重复关键字的容器，接受单个元素的 insert 操作返回一个指向新元素的迭代器，并无序返回一个 bool 值。</p>
<p>15.关联容器的删除操作详见 c++ prime 5th中文版的386页。</p>
<p>16.set 类型不支持下标操作。</p>
<p>17.我们不能对一个 multimap 或一个 unordere_multimap 进行下标操作，因为一个关键字可能与多个值对应。</p>
<p>18.如果我们使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到 map 中。所以当我们不想在元素不存在的情况下添加元素，那么这种情况下不能使用下标操作。</p>
<p>19.当对一个 map 进行下标操作时，会获得一个 mapped_type 对象，但当解引用一个 map 迭代器时，会得到一个 value_type 对象。</p>
<p>20.关联容器的查找操作详见 c++ prime 5th中文版的388页。</p>
<p>21.如果一个 multimap 或 multiset 中有多个元素与一个关键字相关联，那么这些元素在容器中会相邻存储。</p>
<p>22.当我们遍历一个 multimap 或 multiset 时，保证可以得到序列中所有具有给定关键字的元素。</p>
<p>23.如果关键字在容器中，lower_bound 返回的迭代器将指向第一个具有给定关键字的元素，而 upper_bound 返回的迭代器则指向最后一个指向给定关键字的元素之后的位置，对同一个关键字同时调用这两个成员函数可以表示该关键字的元素范围。<br>例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ser&lt;<span class="keyword">int</span>&gt; foo  = &#123;<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">4</span> , <span class="number">4</span> , <span class="number">4</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">6</span> , <span class="number">7</span>&#125;;</span><br><span class="line">                           |                    |</span><br><span class="line">	               	lower_bound             upper_bound</span><br></pre></td></tr></table></figure>
<p>24.如果 lower_bound 和 upper_bound 返回相同的迭代器，则给定关键字不在容器中。</p>
<p>25.equal_range 接受一个关键字，返回一个 pair ，如果匹配成功 first 成员保存的迭代器与 lower_bound 返回的一样，second 成员保存的迭代器与 upper_bound 返回的一样，如果匹配失败则两个迭代器指向关键字可以插入的位置。</p>
<p>26.如果关键字类型固有就是无序的，或者性能测试发现可以用哈希技术解决，就可以使用无序容器。</p>
<p>27.无序容器在存储上组织为一组桶，每个桶保存另个或多个元素。无序容器使用一个哈希函数将元素映射到桶。</p>
<p>28.无序容器管理操作详见 c++ prime 5th中文版的395页。</p>
<p>29.自定义类类类型的无序容器关键字类型的要求详见 c++ prime 5th 中文版的396页。</p>
<h2 id="动态内存">动态内存</h2><p>1.静态内存用来保存局部 static 对象、类 static 数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非 static 对象。</p>
<p>2.分配在静态或栈内存中的对象由编译器自动创建和销毁，但是对于栈对象仅在其定义的程序块运行时才存在，static 对象在使用之前分配，在程序结束时销毁。</p>
<p>3.程序用堆来存储动态分配的对象，并且控制这些对象的生存期。</p>
<p>4.智能指针的三种类型都定义在 memory 头文件中。</p>
<p>5.智能指针也是模板，因此在创建的时候必须提供指针可以指向的类型。<br>如： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1；</span><br></pre></td></tr></table></figure>
<p>6.关于 shared_ptr 和 unique_ptr 都支持的操作详见  c++ prime 5th 中文版的 401页。</p>
<p>7.关于 shared_ptr 独有的操作详见 c++ prime 5th 中文版的 401页。</p>
<p>8.我们可以使用 make_shared 来初始化一个 shared_ptr 对象。<br>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p2 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>,<span class="string">'9'</span>);</span><br><span class="line"><span class="comment">// 值得一提的是 make_shared 函数是最安全的分配动态内存的方法，定义在memory头文件中</span></span><br></pre></td></tr></table></figure>
<p>9.每一个 shared_ptr 都有一个关联的引用计数器，每当我们拷贝一个 shared_ptr 作为参数传递给一个函数，或者作为函数值返回的时候它就会递增，当我们赋一个新值或者销毁 shared_ptr对象的时候就会递减。如果计算器递减至零的时候，那么 shared_ptr 就会通过析构函数释放它占用的内存。</p>
<p>下面，我们来看几个在函数中用 shared_ptr 处理局部变量的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; bar (T arg)</span><br><span class="line">&#123;  	<span class="comment">// 对 arg 进行一系列处理</span></span><br><span class="line">    <span class="keyword">return</span> make_shared&lt;Foo&gt; (arg)；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将局部变量保存下来由 shared_ptr 负责释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_bar</span> <span class="params">(T arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;Foo&gt; p = bar(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p离开了作用域，当函数结束的时候，shared_ptr 引用计数器递减至零，p被销毁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_bar</span><span class="params">(T arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;Foo&gt; p = bar(arg);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把 shared_ptr 作为函数值返回，shared_ptr 引用计数器加1，</span></span><br><span class="line"><span class="comment">//虽然 p 离开了作用域，但是不会被销毁。</span></span><br></pre></td></tr></table></figure>
<p>10.如果我们将 shared_ptr 存放在一个容器中，而后不再需要全部元素，只是使用其中一部分，<br>        那么我们一定要用 erase 删除不再使用的那个元素。</p>
<p>11.程序在不知道自己需要使用多少个对象、所需对象的准确的类型、以及需要在多个对象之间共享数据时则需要使用动态内存。    </p>
<p>12.运算符 new 在自由空间分配一个无名的对象并返回指向该对象的指针。<br>关于 new 和 malloc 的区别请看：</p>
<p>13.只有当括号中仅有单一初始化器时才可以用 auto 。</p>
<p>14.对于一个定义了默认构造函数的类类型，其 const 动态对象可以隐式初始化，而其他类型的对象就必须显示初始化。</p>
<p>15.默认情况下，如果 new 不能分配所要求的内存空间，它会抛出一个类型为 bad_alloc 的异常。</p>
<p>16.定位 new 表达式允许我们向 new 传递额外的参数<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new 抛出 std::bad_alloc	</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new 返回一个空指针</span></span><br><span class="line"><span class="comment">//将 nothrow 传递给 new 的意思就是让 new 不抛出异常，分配失败则返回一个空指针。</span></span><br><span class="line"><span class="comment">//bad_alloc 和 nothrow 定义在头文件 new 中。</span></span><br></pre></td></tr></table></figure></p>
<p>17.传递给 delete 的指针必须指向一个动态分配的内存，或者是一个空指针，拷贝的不可以。</p>
<p>18.空悬指针指的是指向一块曾经保存数据但是现在已经无效的内存的指针。</p>
<p>19.虽然 const 对象的值不能被改变，但它本身是可以被销毁的。但是不能把一个局部变量或者空悬指针传给 delete 。</p>
<p>20.普通指针在离开其作用域时，它所指向的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存不会被自动释放，除非它被显示释放。</p>
<p>21.使用 new 和 delete 管理动态内存的三个常见问题：</p>
<ul>
<li>1.忘记 delete 内存</li>
<li>2.使用已经释放的对象。</li>
<li>3.同一块内存连续释放两次。</li>
</ul>
<p>22.如果我们有两个普通指针指向同一个对象，那么其中一个被 delete 之后，另一个要赋予 nullptr。</p>
<p>23.接受指针参数的智能指针的构造函数是 explicit 的，同时我们不能进行普通指针与智能指针间的隐式转换，所以必须使用直接初始化形式。<br>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>) ; </span><br><span class="line"><span class="comment">// 错误 不能使用赋值初始化，因为不能进行隐式转换。</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>));  </span><br><span class="line"><span class="comment">// 正确 使用直接初始化</span></span><br></pre></td></tr></table></figure>
<p>24.自定义其他类型的 shared_ptr 和改变 shared_ptr 的其他方法详见 c++ prime 5th中文版的 412 页。</p>
<p>25.shared_ptr可以协调对象的析构，但这仅限于自身的拷贝，所以应该使用 make_shared 初始化一个 shared_ptr，而不是 new。</p>
<p>26.当将一个普通指针托管给 shared_ptr 之后，就不应该再使用内置指针来访问这个普通指针指向的内存。</p>
<p>27当我们需要向不能使用智能指针的代码传递一个内置指针的时候，我们可以使用 get 函数。get 函数它返回一个内置指针指向智能指针管理的对象，但是我们不能 delete 这个指针。因为 get 只用来将指针的<strong>访问</strong>权限传递给代码，所以永远不可以用 get 初始化另一个智能指针或给另一个智能指针赋值。</p>
<p>28.reset 函数可以将一个新的指针赋予一个 shared_ptr （断开共享）。reset 会更新引用计数，如果有需要会释放 p 指向的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p.unique())</span><br><span class="line">	p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line">*p += newVal;</span><br></pre></td></tr></table></figure>
<p>29.在程序块过早结束的时候(正常处理结束或者发生异常)，智能指针能确保安全的释放对象，但是内置指针就不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">42</span>));  <span class="comment">//分配一个新对象</span></span><br><span class="line"><span class="comment">//这段代码抛出一个异常，且在 f 中未被捕获</span></span><br><span class="line"><span class="comment">//在函数结束时 shared_ptr 检查引用计数，</span></span><br><span class="line"><span class="comment">//在此类中 sp 是这块内存的唯一指针，所以结束时会自动释放内存。</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>); <span class="comment">// 分配一个新对象</span></span><br><span class="line"><span class="comment">// 这段代码抛出一个异常，且在 f 中未被捕获</span></span><br><span class="line">	<span class="keyword">delete</span> ip; </span><br><span class="line"><span class="comment">// 如果在new 之后，delete 之前发生了异常且未被捕获，</span></span><br><span class="line"><span class="comment">//同时在 f1 之外就没有指针指向这块内存，所以无法释放它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30.智能指针的使用规范：</p>
<ul>
<li>1.不使用相同的内置指针值初始化（或 reset）多个智能指针。</li>
<li>2.不 delete get() 返回的指针。</li>
<li>3.不使用 get() 初始化或 reset 另一个智能指针。</li>
<li>4.如果我们使用了 get() 返回的指针，记住当最后一个对应的智能指针销毁后，我们的指针就无效了。</li>
<li>5.如果我们使用智能指针管理的资源不是 new 分配的内存，记得要传递给它一个删除器。</li>
</ul>
<p>31.当我们定义一个 unique_ptr 时，需要将其绑定到一个 new 返回的指针并且必须采用直接初始化形式。<br>值得注意的是：在某个时刻只能有一个 unique_ptr 指向给定对象，所以 unique_ptr 不支持普通拷贝和赋值操作。<br>例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Stegosaurus"</span>));</span><br><span class="line">unique_ptr&lt;<span class="built_in">string</span>&gt; p1(p2);		<span class="comment">// 错误： unique_ptr 不支持拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="built_in">string</span>&gt; p3;</span><br><span class="line">p2 = p3；	<span class="comment">//错误： unique_ptr 不支持赋值</span></span><br></pre></td></tr></table></figure>
<p>32.关于 unique_ptr 操作详见 c++ prime 5th中文版的 418 页。</p>
<p>33.虽然不能拷贝 unique_ptr ，但是我们通过从函数里面返回一个 unique_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="keyword">new</span>(<span class="keyword">int</span> (p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还可以返回一个局部对象的拷贝</span></span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; clone(<span class="keyword">int</span> p)</span><br><span class="line">&#123;</span><br><span class="line">	unique_ptr&lt;<span class="keyword">int</span>&gt; ret(<span class="keyword">new</span> <span class="keyword">int</span> (p));</span><br><span class="line">	<span class="comment">// 其他操作</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>34.关于 auto_ptr 详见 c++ prime 5th中文版的 419 页。</p>
<p>35.向 unique_ptr 传递删除器详见 c++ prime 5th中文版的 419 页。</p>
<p>36.weak_ptr 是一种不控制所指向对象生存期的智能指针，指向一个 shared_ptr 管理的对象，不过 weak_ptr 绑定之后，不会改变 shared_ptr 的引用计数，一旦最后一个 shared_ptr被释放，那么即使 weak_ptr 指向对象，对象还是会被释放，所以我们不能用 weak_ptr 直接访问对象，应该先调用 lock 函数检查对象是否存在，如果存在则返回一个指向共享对象的 shared_ptr。</p>
<p>37.关于 weak_ptr 的操作详见 c++ prime 5th中文版的 420 页。</p>
<p>38.当一个应用需要可变数量的对象时，最好使用 vector 这类标准库容器，因为不仅性能好，而且不容易出现内存管理错误。</p>
<p>39.在用 new 初始化动态数组时，如果初始化数目小于元素数目，剩余元素将进行值初始化，如果初始化器数目大于元素数目，则 new 表达式失败，不会分配任何内存，并且抛出一个 bad_array_new_length 异常。</p>
<p>40.虽然我们不能创建一个大小为 0 的静态数组对象，当时调用 new[n] 是合法的，即可以分配一个空数组。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">0</span>]； <span class="comment">// 错误：不能定义长度为0的数组</span></span><br><span class="line"><span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>]； <span class="comment">// 正确，但是 cp 不能解引用</span></span><br></pre></td></tr></table></figure></p>
<p>41.为了释放动态数组，我们使用一种特殊的 delete。<br>例：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span> [] <span class="keyword">cp</span>; // <span class="keyword">cp</span> 必须指向一个动态分配的数组或为空</span><br></pre></td></tr></table></figure></p>
<p>42.如果我们在 delete 一个数组指针时忘记了方括号，或者在 delete 一个单一对象的指针时使用了方括号，<br>编译器不会给出警告。</p>
<p>43.标准库提供了一个可以管理 new 分配的数组的 unique_ptr 。关于指向数组的 unique_ptr 操作 详见 c++ prime 5th中文版的 426 页。</p>
<p>44.标准库 allocator 类定义在头文件 memory 中，它帮助我们将内存分配和对象构造分离开来，它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;	</span><br><span class="line"><span class="comment">// 可以分配 string 的 allocator 对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); </span><br><span class="line"><span class="comment">// 分配 n 个未初始化的 string</span></span><br></pre></td></tr></table></figure></p>
<p>45.关于 allocator 的操作详见 c++ prime 5th中文版的 428 页。</p>
<p>46.我们只能对构造后的 allocate 对象进行 destroy 操作，最后通过调用 deallocate 释放内存。</p>
<p>47.关于 allocator 填充未初始化内存和拷贝的算法详见 c++ prime 5th中文版的 429 页。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="IO类">IO类</h2><p>1.宽字符版本的类型和函数的名字以一个w开始。</p>
<p>2.我们不能将形参或返回类型设置为流类型， 进行io操作的函数以引用方式传递和返回流。</p>
<p>3.确定一个流对象的状态的最简单的方法是将它当作 一个条件来使用： while(cin &gt;&gt; word) 如果流状态正常那么循环继续。</p>]]>
    
    </summary>
    
      <category term="c++" scheme="https://luengzeegin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[keywords in cpp(part one)]]></title>
    <link href="https://luengzeegin.github.io/2015/08/31/keywords-in-cpp/"/>
    <id>https://luengzeegin.github.io/2015/08/31/keywords-in-cpp/</id>
    <published>2015-08-31T08:49:40.000Z</published>
    <updated>2016-02-22T11:30:39.743Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><pre><code><span class="comment">人呐，总是找个地方记一下笔记学习才有动力啊，所以我就把《C</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">prime》</span>
<span class="comment">里面的</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">概念，都摘录下来了，方便自己有时候查看，想想还是不错的，</span>
<span class="comment">除此以外，</span> <span class="comment">我还把一些需要注意的地方和要点也都记录下来，</span> <span class="comment">不过为了版面设计，我把它放在另一篇博文</span>
<span class="comment">《something</span> <span class="comment">important</span> <span class="comment">in</span> <span class="comment">cpp》里面了，</span>
<span class="comment">如果有什么不对的地方，欢迎大家在下面评论。</span>
<span class="comment">毕竟这里只是写出鄙人短浅的观点，还望抛砖引玉。</span>
</code></pre><a id="more"></a>
<h3 id="对象：">对象：</h3><pre><code>具有某种数据类型的内存空间，有一个说法是将对象以有没有命名来区分，
命了名的对象称为变量，没有命名的就称为对象。
</code></pre><h3 id="引用：">引用：</h3><pre><code>为变量起了另一个名字，通过声明符写成&amp;<span class="built_in">i</span>的形式来定义引用类型，
其中<span class="built_in">i</span>是声明的变量名。引用的时候必须被初始化，一旦完成初始化之后，
引用无法重新绑定另一个变量。实际上，完成初始化之后，
引用与它绑定的变量是等价的。函数实参使用引用，
其实有个好处就是把形参与实参联系起来，中间少了一个创建副本的过程。
</code></pre><h3 id="常量引用：">常量引用：</h3><pre><code>所谓常量引用是对<span class="keyword">const</span>的引用，并且常量引用仅对引用可参与的操作进行了限定。
常量引用可以绑定非常量的对象、对面值，甚至是一个表达式，
但是不能通过引用来改变对象的值。注意，不能让一个非常量引用指向一个常量对象。
</code></pre><h3 id="常量表达式">常量表达式</h3><pre><code>值不会改变并且在编译过程中就能得到计算结果的表达式。
</code></pre><h3 id="constexpr类型">constexpr类型</h3><pre><code>该类型声明的变量一定是一个常量，因此必须要用一个常量来进行初始化。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p1 相当于 <span class="keyword">int</span> *<span class="keyword">const</span> p1</span><br></pre></td></tr></table></figure>
<h2 id="auto类型说明符">auto类型说明符</h2><pre><code><span class="keyword">auto</span>说明符能让编译器通过初始值来推算变量的类型。
例如：
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = bar + var </span><br><span class="line"><span class="comment">//如果两个数都为double那么add就是double型。</span></span><br></pre></td></tr></table></figure>
<h3 id="容器vector">容器vector</h3><pre><code>相同类型对象的集合，同时集合中每个对象都有和它一一对应的索引，用于访问对象。注意这里并不包括引用。
</code></pre><h3 id="模板template">模板template</h3><pre><code>模板本身不是类或者函数，不过可以将模板看作为编译器生成的类或者函数
编写的一份声明，编译器根据模板创建类或者的过程称为实例化。
</code></pre><h3 id="范围for">范围for</h3><pre><code class="cpp"><span class="keyword">for</span>(declaration:expression)
    statement
</code></pre>
<pre><code> 1<span class="class">.expresstion</span>是一个给定的序列，<span class="tag">declaration</span>定义一个用于遍历序列的元素，
每次迭代之后，这个元素都会被初始化为序列的下一个元素。

 2.如果需要对序列中的元素执行写操作的时候，循环变量必须声明成引用类型。
</code></pre><h3 id="重载运算符">重载运算符</h3><pre><code>当运算符作用于类类的运算对象时，用户可以自行定义其含义，
但是运算对象的个数、运算符的优先级和结合律都是没有办法改变，
意思就是说二元运算符的操作数就是两个并不能改变为一个。
</code></pre><h3 id="左值和右值">左值和右值</h3><pre><code>一个对象被用作右值的时候，用的是对象的值<span class="comment">(内容)</span>；当对象被用作左值的时候，用的是对象在内存中的位置。
</code></pre><h3 id="try语句块和异常处理">try语句块和异常处理</h3><pre><code> <span class="keyword">throw</span>表达式包含关键字和一个表达式一个分号
    <span class="keyword">throw</span> <span class="keyword">error</span>(<span class="string">"Data error"</span>);
     *返回一个<span class="built_in">string</span>类,异常类型中的what成员接受这个<span class="built_in">string</span>类，
     然后可以通过输出what成员函数来输出文本信息。
<span class="keyword">try</span>表达式包括<span class="keyword">catch</span>子句和异常对象的声明和处理块。
</code></pre><pre><code class="cpp"><span class="keyword">try</span>
{ <span class="keyword">if</span>(……)
    <span class="keyword">throw</span> runtime_error( ……)
}
<span class="keyword">catch</span> (runtime_error 异常对象名)
{
    <span class="built_in">cout</span> &lt;&lt; 异常对象名.what();
    <span class="keyword">do</span> sth.
}
</code></pre>
<h3 id="引用传递">引用传递</h3><pre><code>当形参是引用类型的时候，引用形参也是它绑定的对象的别名。
</code></pre><h3 id="尾置返回类型">尾置返回类型</h3><pre><code class="cpp"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>
</code></pre>
<pre><code>用<span class="attribute">auto</span>代替原来返回类型，然后再形参列表后面用 <span class="string">'-&gt;'</span> 加上真正的返回类型。
</code></pre><h3 id="函数重载">函数重载</h3><pre><code>如果同一个作用域内的几个函数名字相同，但形参列表不同，我们称为重载。不过<span class="keyword">main</span>函数不能重载。
</code></pre><h3 id="构造函数">构造函数</h3><pre><code><span class="number">1.</span>用于初始化类的函数，至少有一个。多个构造函数之间类似函数的重载， 在参数数量与参数类型上有所区别。

<span class="number">2.</span>构造函数的名字要与类名相同。

<span class="number">3.</span>如果我们需要编译器提供默认构造函数，我们在参数列表后面写上<span class="string">" = default "</span>。即：类名<span class="comment">()</span> = default；

<span class="number">4.</span>如果我们需要自己定义构造函数，如 ： 类名<span class="comment">( 参数列表 )</span> 冒号 构造函数初始化列表 { 函数体 } 没有分号
    例：
</code></pre><pre><code class="cpp">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>：：<span class="built_in">string</span> &amp;s) : bookNo(s), units_sold(<span class="number">0</span>) , revenus(<span class="number">0</span>） {　｝;
<span class="comment">// 将字符串ｓ用来初始化bookNo , 用0初始化 units_solds revenus</span>
</code></pre>
<h3 id="委托构造函数">委托构造函数</h3><pre><code>1.委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，
它的形式形如：
类名（参数列表）冒号 所需构造函数 （所需构造函数的参数列表） <span class="rules">{ }</span> 没有分号。
</code></pre><h3 id="可变数据成员">可变数据成员</h3><pre><code>当我们需要在一个<span class="keyword">const</span>成员函数中有一个可改变的数据成员的时候
如统计这个函数运行了多少次，就可以用<span class="keyword">mutable</span>关键字声明这个数据成员。
</code></pre><h3 id="explicit关键字">explicit关键字</h3><pre><code><span class="keyword">explicit</span>关键字主要用在修饰构造函数、复制构造函数。
在函数参数允许隐式类型转换的时候，我们可以使用 <span class="keyword">explicit</span> 来进行阻止。
</code></pre><h3 id="聚合类">聚合类</h3><pre><code>所有成员都是 <span class="keyword">public</span>，没有定义任何构造函数，没有类内初始值，没有基类，也没有 <span class="keyword">virtual</span> 函数。
</code></pre><h3 id="类的静态成员">类的静态成员</h3><pre><code>当类需要一个只与一些成员与类本身直接相关、被所有类对象共享，
而不是与类的各个对象保持关联的对象时，如银行的利率，班级的人数，
我们可以使用 <span class="keyword">static</span> 声明这个成员。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><pre><code><span class="comment">人呐，总是找个地方记一下笔记学习才有动力啊，所以我就把《C</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">prime》</span>
<span class="comment">里面的</span> <span class="comment">c</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">概念，都摘录下来了，方便自己有时候查看，想想还是不错的，</span>
<span class="comment">除此以外，</span> <span class="comment">我还把一些需要注意的地方和要点也都记录下来，</span> <span class="comment">不过为了版面设计，我把它放在另一篇博文</span>
<span class="comment">《something</span> <span class="comment">important</span> <span class="comment">in</span> <span class="comment">cpp》里面了，</span>
<span class="comment">如果有什么不对的地方，欢迎大家在下面评论。</span>
<span class="comment">毕竟这里只是写出鄙人短浅的观点，还望抛砖引玉。</span>
</code></pre>]]>
    
    </summary>
    
      <category term="c++" scheme="https://luengzeegin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Note in c++ prime 5th (chap1-7)]]></title>
    <link href="https://luengzeegin.github.io/2015/08/31/something-important-in-cpp/"/>
    <id>https://luengzeegin.github.io/2015/08/31/something-important-in-cpp/</id>
    <published>2015-08-31T08:47:59.000Z</published>
    <updated>2017-02-15T14:36:01.714Z</updated>
    <content type="html"><![CDATA[<pre><code>这篇文主要是记录的《c++ prime》里面第一部分的一些我认为有必要记录下来的关键点，
这里面包括了书上 <span class="keyword">warning</span> 和 note 以及一些我会觉得我将来需要回头的看的部分。
不过收录的并不是很详细，因此这篇文起到的作用更多是一个框架。
</code></pre><a id="more"></a>
<h2 id="初始化&amp;赋值">初始化&amp;赋值</h2><p>1.初始化不是赋值，初始化的含义是创建变量时赋予它一个初始值，就是为这个变量开辟一个内存空间。而赋值的含义是把对象的当前值擦除，然后用一个新值替代。</p>
<p>2.定义于任何函数体之外的变量被初始化为0，定义于函数内的内置类型的对象，如果没有初始化，它的值则没有定义。此外，类的对象如果没有显式的初始化，则其值由类决定。</p>
<p>3.如果要初始化一个含有元素值的列表，那么只能把初始值都放在花括号里进行列表初始化。</p>
<h2 id="头文件声明">头文件声明</h2><p>1.使用ifndef，可避免重定义，但是在XXXX.h 中的 <strong>.</strong> 要使用下划线 <strong>_</strong> 代替。</p>
<h2 id="定义&amp;声明">定义&amp;声明</h2><p>1.声明是让变量的名字让程序知道，而定义则是创建一个内存空间并且与变量的名字挂钩。此外，一个变量只能定义一次，并且变量的定义只能出现在一个文件中，如果其他文件需要使用就必须对这个变量进行声明。</p>
<h2 id="const">const</h2><p>1.const 对象一旦创建就必须初始化。在默认状态下，const 对象仅在文件内有效，如果想在多个文件里面使用 const 对象，那么必须在变量定义之前添加 extern 。</p>
<p>2.顶层 const 对象的内容是固定不变的，而底层 const 对象的含义是对象拥有 const 这样一种属性。</p>
<p>3.用于声明引用的 const 都是底层 const 。</p>
<p>4.普通的拷入和拷出并不会影响拷贝对象的值，但是底层的 const 的限制执行拷入和拷出操作时，两个对象的数据类型要匹配，或者能进行类型转换。</p>
<p>5.对常量对象取地址是一种底层const。因为常量对象是不允许改变，那么相应的地址也是固定的（在函数体外定义的对象），因此指向他的指针自然也是固定的。</p>
<p>6.对于常量的 const 只能读不能写。</p>
<p>7.当数据不需要修改的时候，最好都要使用常量。</p>
<h2 id="别名声明">别名声明</h2><p>1.传统的方式是用typedef，这里不作赘述，c++11规定一种新的方式：<br>using 别名 = 类型名，<br><strong>注意</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> cpointer = <span class="keyword">char</span> *;</span><br><span class="line">cpointer p1;</span><br><span class="line"><span class="keyword">char</span> *p1;</span><br><span class="line"><span class="comment">//此处两个 p1 并不完全等价</span></span><br><span class="line"><span class="comment">//因为前者的数据类型是指针，而后者数据类型是char 而"*"则是声明符的一部分。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="auto类型符">auto类型符</h2><p>1.使用auto只能声明一个基本类型的多个变量，因此所有变量的初始基本数据类型都是 必须一样。<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>,*p = &amp;i  <span class="comment">// 那个p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>,j = <span class="number">3.14</span>  <span class="comment">// 错误类型不一致</span></span><br></pre></td></tr></table></figure></p>
<p>2.auto一般会忽略顶层const，如果想推断出的auto是顶层就要显式的写明const、 auto，但是在设置为auto型的引用时，初始值中的顶层属性会被保留，不过底层的const会 保留下来。<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">auto</span> a = ci ; <span class="comment">// a为整数被忽略</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = ci ; <span class="comment">// 整型常量引用没被忽略</span></span><br></pre></td></tr></table></figure></p>
<p>3.在auto中，‘*’和‘&amp;’只从属于某个声明符，并不是数据类型的一部分，所以初始值必须是同一个类型。<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;m = ci,*p = &amp;ci; <span class="comment">// 正确 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i,*p2 = &amp;ci; <span class="comment">// 错误 int，const int</span></span><br></pre></td></tr></table></figure></p>
<h2 id="decltype类型标识符">decltype类型标识符</h2><p>1.只要decltype((变量名))那出来的都是引用。</p>
<p>2.decltype()括号里面是左值，那么类型就是引用。常见的是decltype(<em>p）假设p是  int</em>  ,那么decltype生成的是 int &amp;</p>
<p>3.constdecltype((i))中，const不会发生作用。<br>这里的<strong>const</strong>修饰的是<strong>decltype((i))</strong>，假设 i 是 int 类型，那么decltype的结果就是<strong>int类型</strong>的引用，那么 const 修饰int型的引用，<br>相当于 <strong>int&amp;  const</strong>，那么为什么不是 <strong>const int&amp;</strong>呢？<br>那是因为 <strong>const int&amp;</strong> 就是对整型常量的引用，改变了 <strong>int&amp;</strong> 的结构，所以两者并不等价。那么我们回到 <strong>int &amp; const</strong>，因为引用本来就不能被修改，因此 <strong>const</strong> 就不起作用，所以 <strong>const decltype</strong> 语句相当于 <strong>int &amp;</strong>。</p>
<p>4.常用于推断已知函数或者表达式的表达式类型，auto 则是根据初始化的值推断对象的类型。</p>
<p>5.当decltype作用于数组类型的时候，它返回是的仍是个数组（类型 + 维度），并不会将数组转换成指针。</p>
<p>6.最好不要用decltype返回一个指针类型，最妥当的方法是：先用decltype返回基类型，然后再加上 <strong>*</strong> 修饰符。</p>
<h2 id="string类">string类</h2><p>1.例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt; using std::string；</span></span><br><span class="line"><span class="built_in">string</span> s1；</span><br><span class="line"><span class="comment">// 默认初始化是空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(100,'c')</span>； </span><br><span class="line"><span class="comment">// 将s2初始化成100个c的串</span></span><br><span class="line"><span class="built_in">string</span> s2（s1）； </span><br><span class="line"><span class="comment">// 将s2是s1 直接初始化 s2=s1 拷贝初始化</span></span></span><br></pre></td></tr></table></figure></p>
<p>2.string对象会自动忽略开头空白若输入“    abc”则输出结果就是abc。</p>
<p>3.string类相加的时候加号两边的对象至少一个是string。</p>
<p>4.C语言中的字符串字面值跟C++中的string并不是同一样东西。</p>
<p>5.只要操作数里面含有string类，那么就应该加上#include<string>。</string></p>
<p>6.std里面的toupper只支持单个字符，而boost中里面则支持vector。</p>
<p>7.可使用 <strong>c_str</strong> 成员函数将 string 转换成 <strong>char</strong>，但是一旦 string 改变这个 <strong>char</strong> 就有失效的可能，因此要用这个返回的<strong>char</strong> 最好先备份一下。    </p>
<p>8.对于使用 string 的元素，最好设置为引用类型，可以避免对元素的拷贝。</p>
<p>9.构造 string 的其他方法详见 c++ prime 5th 中文版的321页。</p>
<p>10.如果我们从一个 const *char 创建 string 时 ，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们在构造数组时不传递计数值并且数组也未以空字符结尾，或者计数值大于数组大小，那么构造函数的行为是未定义的。</p>
<p>11.修改 string 的操作详见 c++ prime 5th 中文版的323页。</p>
<p>12.string 子字符串的操作 substr 详见 c++ prime 5th 中文版的322页。</p>
<p>13.assign 总是替换 string 中所有内容， append 总是将新字符追加到末尾。</p>
<p>14.string 的搜索操作详见 c++ prime 5th 中文版的325页。</p>
<p>15.每个搜索操作都会返回一个 <em>string::size_type</em> 表示位置下标，如果搜索失败则返回一个 <em>string::npos</em> 的 <em>const static</em> 成员数据类型为 unsigned，大小初始化为-1。</p>
<p>16.如果要搜索第一个不在参数中的字符，我们应该调用 <em>find_first_not_of</em> </p>
<p>17.如果要搜索与给定 string 中任何一个字符匹配的最后一个字符，那么我们应该调用 <em>find_last_of</em></p>
<p>18.如果要搜索最后一个不出现在给定 string 中的字符，那么我们应该调用 <em>find_last_not_of</em> 。</p>
<p>19.string比较的相关操作详见c++ prime 5th的327页。</p>
<p>20.string 和 数值之间的转换详见c++ prime 5th 的328页。</p>
<p>21.如果 string 不能转换为一个数值，这些函数抛出一个 <em>invalid_argument</em> 异常，如果转换得到的数值无法用任何类型表示，则抛出一个 <em>out_of_range</em> 的异常。</p>
<h2 id="getline">getline</h2><p>1.getline遇到换行符则结束读取操作并返回结果，尽管一开始就是换行符，但是用于接收的string是不会存入换行符。</p>
<p>2.getline 不会跳过前导空格，可以使用 substr 跳过前导空格。</p>
<h2 id="string-size">string.size</h2><p>1.返回的是字符串中字符的个数，注意如果一条表达式中已经有了 size() 函数的话，就不要使 用int了，因为 size 返回的 unsigned int 如果返回值与一个有符号整数比较的话，容易出问题。</p>
<h2 id="vector容器">vector容器</h2><p>1.假如 vector 的元素仍是vector的话，旧式声明是：vector<vector<int>空格&gt; ,<br>新式的声明则是：vector<vector<int>&gt; 。</vector<int></vector<int></p>
<p>2.使用 vector<int> ivec(10,1) 来批量初始化。</int></p>
<p>3.vector 初始化如果用的是圆括号，那么提供的值就是用来说明这个 vector 对象元素的个数和初始值；如果 vector 初始化用的是花括号，那么就是一个 vector 对象元素里面的初始值。注意对于 vector 的初始化不宜使用拷贝初始化，应该使用直接初始化。</p>
<p>4.向 vector 对象中添加元素时不能使用范围for循环。要用 while 或者普通循环，接着一定 要使用 push_back 函数推入 vector 的尾部，而不能用下标法给 vector 对象赋值，<br>因为一个空的 vector 对象不含任何元素。</p>
<p>5.vector对象的类型总是要包括元素的类型。<br>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="keyword">size_t</span>ype;  <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::<span class="keyword">size_t</span>ype;       <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p>
<p>6.可以使用以下形式，使用数组来初始化vector：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; testing(begin(a), end(a)); 	<span class="comment">// begin返回的是一个地址</span></span><br></pre></td></tr></table></figure></p>
<p>7.当返回值是一个vector的时候，应该使用引用形式。<br>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vectorIn,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vectorOut)</span></span></span><br></pre></td></tr></table></figure></p>
<p>8.vector 中元素必须连续保存，所以在增容的时候，容器必须分配新的内存空间来保存已有元素和新元素，将已有元素旧位置移动到新空间中，然后添加新元素，释放旧存储空间。</p>
<p>9.每个vector都可以选择自己的内存分配策略，但是只有当迫不得已的情况下才可以分配新的内存空间。</p>
<p>10.push_back 向 vector 添加元素的操作具有高效率，在一个空的 vector 上调用 n 次 push_back 来创建一个 n 个元素的  vector 所花费的时间不能超过 n 的常数倍。</p>
<h2 id="迭代器">迭代器</h2><p>1.迭代器中end成员返回的是容器尾元素的下一个位置的迭代器，虽然这个尾迭代器不 包括在容器里面，但是它起到一个标志的作用，<br>因此并不能对这个尾迭代器进行运算。</p>
<p>2.迭代器的类型分别为 <em>const_iterator</em> 和 <em>iterator</em> 前者能读取对象的值，但是不能修改它的值，后者既能读写又能修改。</p>
<p>3.cbegin 和 cend 两个函数，不论原来的 string 或者是 vector 是否为常量，    这个函数的 返回值都是 <em>const_iterator</em>。</p>
<p>4.迭代器的类型是类，然后又要访问它的成员的话，那么可以类比结构体指针 使用<strong>-&gt;</strong>箭头运算符。</p>
<p>5.任何一种可能改变vector容量的操作，都会这个对象的迭代器失效。</p>
<h2 id="数组">数组</h2><p>1.在 cstddef 里面定义了 <strong>size_t</strong> 类型——足够大的无符号数字来表示下标。</p>
<p>2.在数组里面用begin和end函数来返回数组的首指针还有尾元素下一位置的指针，<br>使用方法 ：*beg=begin（数组名），<br>两个函数都包含在iteartor头文件中。</p>
<h2 id="下标">下标</h2><p>1.标准库类型的下标必须是无符号类型，而内置的下标运算不是无符号类型，就是可以用负号，就是下列代码可以通过运行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> k = p[-<span class="number">2</span>]; </span><br><span class="line"><span class="comment">// p是a数组a的第三个元素的地址，k就是指向数组的第一个元素。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="左值和右值">左值和右值</h2><p>1.<em>p生成的是左值：p是指针对象存储的是<strong>指向的地址</strong>，</em>p取出这个地址，所以生成的是左值<br>2.&amp;p生成的是右值：取p的地址赋给指针对象，即生成的是<strong>对象的内容</strong>，所以生成的是右值。</p>
<h2 id="布尔运算">布尔运算</h2><p>1.先给两行代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">bool</span> b2 = -b ; <span class="comment">//b2也是true</span></span><br><span class="line"><span class="comment">//b是true意味着整型值是1，那么-b的整型值就是-1，-1的bool值是true。</span></span><br></pre></td></tr></table></figure></p>
<p>2.进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象。</p>
<h2 id="取余运算">取余运算</h2><p>m%(-n) 等 于m%m </p>
<p>(-m)%n 等于 -(m%n)</p>
<h2 id="sizeof运算符">sizeof运算符</h2><p>1.对char或者类型为char的表达式执行sizeof运算，结果为1。</p>
<p>2.对引用类型执行sizeof运算得到被引用对象所占空间的大小。</p>
<p>3.对指针执行sizeof运算得到指针本身所占空间的大小，int型指针64位就是4</p>
<p>4.对解引用指针(<em>p)执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。 
</em>p-&gt;a ，结果就是a的大小。</p>
<h2 id="命名的强制类型转换">命名的强制类型转换</h2><p><strong>cast-name<type>(expression)</type></strong></p>
<p>1.static_cast:任何具有明确类型定义的类型转换，只要不包括底层const都可以用这个，特别是在 <strong>较大算术类型转换为较小</strong> 的时候很有用。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = &amp;d; <span class="keyword">double</span> *db = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<p>2.const_cast:只能改变运算对象的底层const，简单的说就是去掉const的形式，将一个<strong>常量对象改为 非常量对象</strong>。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p; <span class="keyword">char</span> *dp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<p>3.reinterpret_cast：运算对象的位模式提供较低层次上的重新解释 <em>（这个坑先留着）</em></p>
<h2 id="switch_内部的变量定义">switch 内部的变量定义</h2><p>1.为了防止变量的初始化和使用域不在一个块上，<br>所以switch 内部的变量定义的方法应该是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">true</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 加上一个花括号</span></span><br></pre></td></tr></table></figure></p>
<p>流<br>-</p>
<p>所谓流，我们可以把它跟我们生活中的水流类比，<br>重载运算符 &gt;&gt;就很好的说明了这个特征，我感觉这个 &gt;&gt; 运算符就好像波浪啊。在数据结构里面，其实链表也算是一种流的形式，每个表直接都有连接，一环扣一环，得知前一个表才能找到后一个表的方向。所以我们在操作流的时候不妨类比一下链表的操作，说不定会有新的发现。</p>
<h2 id="函数的返回">函数的返回</h2><p>1.在含有return语句的循环后面应该也有一条return语句，如果没有的话，在程序不进入这个循环的时候，那么这个程序就会出错。</p>
<p>2.不要返回局部对象的引用或指针，因为局部对象或者指针都存放在一个临时的空间里 ， 一旦函数结束之后，这部分空间就会收回，那么局部对象就会消失。</p>
<h2 id="重载">重载</h2><p>1.重载依赖于匹配，当不存在精确匹配的时候，则选择最优匹配，如果存在两个“最优” 匹配，那么就会出现二义性错误。</p>
<p>2.一个拥有顶层const的形参无法和另一个没有顶层const的形参区分。<br>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(<span class="keyword">int</span> *)</span></span><br><span class="line"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> )</span></span><br><span class="line"><span class="comment">// 以上两个声明都是等价的。</span></span></span><br></pre></td></tr></table></figure></p>
<p>3.如果形参是某种类型的引用或者是指针类型，那么根据是非常量对象还是常量对象可以实现函数的重载，这是const是底层的。</p>
<p>4.const_cast能将返回类型是const的函数，变成返回非常量的函数。</p>
<h2 id="默认实参">默认实参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> sz = <span class="built_in">string</span>::<span class="keyword">size_t</span>ype;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = 24 , sz wid = 80 , <span class="keyword">char</span> backgrnd = ' ')</span></span>;</span><br><span class="line"><span class="comment">//调用的时候只需：window = screen() 则自动调用默认参数</span></span><br></pre></td></tr></table></figure>
<p>1.一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p>2.函数后续的声明只能为没有默认值的形参添加默认实参，同时该形参右侧的所有形参 都要有默认值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window = screen(, , <span class="string">'?'</span>);	<span class="comment">//错误：只能省略尾部的实参</span></span><br><span class="line">window = screen(<span class="string">'?'</span>);		<span class="comment">// 调用screen('?' ,80,' ')</span></span><br><span class="line">window = screen(<span class="number">66</span> , <span class="number">128</span> , <span class="string">'#'</span>); <span class="comment">//正确调用</span></span><br></pre></td></tr></table></figure></p>
<p>3.默认形参只能被赋予一次，我们不能修改一个已经存在的默认实参。</p>
<p>4.在使用默认实参时，尽量把经常需要修改的参数放在前面，把不怎么需要经常修改的  参数放在后面，同时要在函数声明中指明默认实参，并将该声明放在合适的头文件中。</p>
<p>5.默认实参已经在函数定义处设置好，局部变量并不能影响默认实参。</p>
<h2 id="内联函数与constexpr函数">内联函数与constexpr函数</h2><p>1.内联函数可以避免函数调用的开销，适用于规模较小，流程直接，频繁调用的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp;</span><br><span class="line">shorterString(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; shorterString(s1,s2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>2.constexpr函数的返回类型及所有形参的类型都要是字面值类型，不过constexpr函数的返回值不一定是常量表达式。</p>
<h2 id="程序调试">程序调试</h2><p>1.assert处理宏定义在cassert里，assert(expr)首先对expr求值，如果为假，程序终止 并输出信息，如果为真则assert什么也不做。</p>
<p>2.assert与预处理命令NDEBUG有关系，NDEBUG -&gt; no debug 关闭调试状态，一般来说系统默认是启用调试状态的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  NDEBUG <span class="comment">//关闭调试状态</span></span></span><br></pre></td></tr></table></figure></p>
<p>3.在使用assert的时候，最好不要连续多次使用assert，因为assert每次只能判断一个条件，这样不利于判断究竟程序在哪一个assert出了问题。</p>
<p>类<br>-</p>
<p>1.类的基本思想是数据抽象和封装，因此调用类有点类似于调用函数，不过身为类的作者还要思考如何做好数据的抽象。</p>
<p>2.类的成员函数的声明必须在类的内部，但是类的定义既可以在类的内部也 可以在类的外部。</p>
<p>3.一般来说，如果非成员函数是类接口的组成部分，则这些函数的生命应该与类在同一个头文件里。</p>
<p>4.当成员函数需要使用其他类型的时候，如果使用其他类的的时候我们需要使用引用，如果我们的操作会改变这个类的内容那么就要设置为普通引用，否则设置为常量引用。在对普通引用数据进行处理的时候，如果我们不想损坏原有数据，那么我们可以将这个对象拷贝给一个新建的副本，然后再进行处理，然后返回这个副本即可。</p>
<p>5.访问说明符public之后的成员在整个程序内可被访问，多数用来定义类的接口，访问说明符<strong>private</strong>可以被类的成员函数或者友元访问多数用来定义类的数据类型。</p>
<p>6.class关键字默认访问权限是 private，struct 关键字默认权限 public 。</p>
<p>7.定义在类内部的成员函数是自动inline，不过最好在<strong>类外部</strong>定义的地方说明inline，并且 inline 的成员函数也应该与相应的类定义在同一个头文件之中。</p>
<p>8.在类中初始化成员的时候用 “ = “  初始化数据成员，用” { } “ 初始化容器。</p>
<p>9.序列调用中，前一个调用函数的返回对象要与后一个调用函数的对象要相兼容或者一致。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myScreen.move(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">'#'</span>)；</span><br><span class="line"><span class="comment">//move 和 set 函数都是返回 screen 的引用，</span></span><br><span class="line"><span class="comment">//如果前者是 const&amp; ,而后者 set 调用的非常量对象，那么这个序列调用将会报错。</span></span><br></pre></td></tr></table></figure></p>
<p>10.在序列调用中，如果调用函数不是引用类型而是普通类型，那么这个函数返回的不是对象本身而是对象的一个副本。相当于整个函数调用完之后原来的对象并没有发现改变，发生改变的是函数调用的时候生成的一个临时值。</p>
<p>11.一旦一个类的名字出现后，它就被认为是声明过了(但没有定义)，因此类里面允许包含指向它自身类型的引用或指针。简单的说就是 class foo 或 struct bar 出现之后，在foo和bar的 { } 中就用 “ foo <em>“ 和 “ bar </em>“</p>
<p>12.要是a类中要调用b类中的成员函数，那么b要在a之前声明。</p>
<p>13.当函数定义在类的外部的时候，返回类型中使用的名字都位于类的作用域之外，这是要用” :: “指明它是哪个类的成员。</p>
<p>14.编译器处在完里中的全部声明之后才会处理成员函数的定义。</p>
<p>15.在类中类型名的定义通常出现在类的开始处，并且如果类里面使用了外层作用域中表示类型的名字，那么类之后不能重新定义该名字。</p>
<p>16.在成员函数中如果对象名与外层作用域中重复，但是我们又需要用到这个外层作用域中的对象，<br>那么我们可以用作用域运算符<strong>::</strong>强制访问外层对象，类中的对象同理，不过也可以也用this指针强制访问成员。    </p>
<p>17.在类成员中如果是const、引用、或者属于某种类型未提供默认构造函数的类类型，那么我们必须通过构造函数初始值列表为这些成员提供初始值。</p>
<h2 id="友元">友元</h2><p>1.友元的声明只能出现在类定义的内部，最好在类定义开始或者结束的位置集中声明友元，这样容易知晓友元的具体情况。为了使友元对类用户可见，我们通常把友元的声明与类的本身放置在同一个头文件中。</p>
<p>2.友元关系不存在传递性，每个类负责控制自己的友元类或友元函数。</p>
<p>3.当一个名字出现在一个友元声明中，我们隐式地假定该名字在当前作用域中是可见的。</p>
<p>4.类内友元声明与定义作用域在类之中，若成员函数在外部定义时要调用友元函数，那么在外部也要声明友元函数。</p>
<h2 id="this指针">this指针</h2><p>1.类的成员函数通过 this 指针来访问调用它那个对象，任何自定义名为 this 的参数或者变量的行为都是非法的，一般情况下 this 的类型都是指向类类型非常量版本的常量指针，如果我们需要调用一个返回常量的成员函数，我们需要把 const 关键字放在函数的参数列表之后，这样以后， this 指针将是一个指向常量的指针。</p>
<p>2.我们无须使用this指针来访问某一个特定的调用者的成员，而是需要把调用函数的对象当作一个整体使用，即返回时我们应该 return *this。</p>
<p>3.在类要使用某一个private成员，可以直接使用，因为在类中this是隐式使用的。</p>
<h2 id="构造函数">构造函数</h2><p>1.构造函数没有返回类型，且构造函数不能声明成const，它的作用类似于回调函数(在类对象(A层)中调用构造函数(B层)初始化类对象(A层))起到一个接口的作用。</p>
<p>2.如果我们没有创造一个构造函数，那么编译器会给我们创造一个默认构造函数，但是对于指针或者数组来说这样的默认构造函数是存在风险的。</p>
<p>3.如果一个类在某种特定的情况下需要控制对象初始化，那么我们就要定义一个默认 的构造函数。</p>
<p>4.如果 “ = default “ 在类的内部，则默认构造函数是内联的，相反，如果它在类的外部那么默认不是内联。</p>
<p>5.构造函数不应该轻易覆盖掉类内初始值，除非新赋的值跟原值不一样，如果我们不能使用类内初始值（指针），则所有构造函数都应该显式的初始化每个内置的成员，而且我们应该使用构造函数的初始值，避免出现 const 、引用这种因未绑定而出现的错误。</p>
<p>6.构造函数初始值的顺序与成员声明的顺序保持一致，所以尽量避免使用某些成员初始化 其他成员。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> X </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    X(<span class="keyword">int</span> val) : j(val) , i(j) &#123; &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//初始化失败，因为i先被初始化，不能用未初始化的j来初始化i。</span></span><br></pre></td></tr></table></figure></p>
<p>7.在委托构造函数中，如果函数体中包含代码的话，那么先执行的受委托构造函数的初始值列表，然后是受委托函数的的函数体，最后才是委托者的函数体。例子可以<a href="http://blog.csdn.net/qq844352155/article/details/27121951" target="_blank" rel="external">看这里</a></p>
<p>8.如果vector对象中是类类型，那么这个类一定至少包含一个默认构造函数来初始化 这个对象。</p>
<h2 id="explicit关键字">explicit关键字</h2><p>1.这个关键字只对一个实参的构造函数有效，因为需要多个实参的构造函数不能用于执行隐式转换。</p>
<p>2.只能在类内声明构造函数的时候使用explicit关键字，在类外部定义构造函数不应重复。</p>
<p>3.使用explicit关键字声明构造函数后，这个构造函数只能以直接初始化的形式使用，不能使用赋值初始化，并且编译器将不会再自动转换过程中使用该构造函数。</p>
<p>4.关于explicit关键字我觉得有一篇博文写的很清楚，欢迎大家过去看一看，就能理解了。<a href="http://www.programlife.net/cpp-explicit-keyword.html" target="_blank" rel="external">传送门</a></p>
<h2 id="聚合类(结构体)">聚合类(结构体)</h2><p>1.显示地初始化类的对象成员时，在添加或者删除一个成员之后，所有的初始化语句都需要更新。</p>
<h2 id="constexpr构造函数">constexpr构造函数</h2><p>1.constexpr构造函数体一般来说是空的，因为构造函数是回调函数不能包含返回语句，而constexpr函数唯一可执行的语句就是返回语句。</p>
<h2 id="类的静态成员">类的静态成员</h2><p>1.类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Meun</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 省略若干构造函数与接口</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">int</span> SaleNum ；</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">double</span> Price = <span class="number">8.6</span>；</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> tips = <span class="number">3.8</span> ;</span><br><span class="line"><span class="comment">//当Meun初始化的时候这个对象就包含SaleNum，</span></span><br><span class="line"><span class="comment">//而Price成员被所有Meun对象共享。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.因为静态成员不与任何对象绑定在一起，它们不包含this指针，所以静态成员不能声明称const，而且也不能在static函数体内使用this指针，这个限制不但适用在this指针的显式使用，而且对调用非静态成员函数的隐式使用有效。</p>
<p>3.我们可以通过使用域运算符直接访问静态成员，也可以通过类的某个对象的引用或者指针来访问静态成员。<br>例：</p>
<pre><code class="cpp">Meun foo;
Meun *foopointer = &amp;foo;
<span class="keyword">double</span> t = foo.Price;
<span class="keyword">double</span> t = foopointer-&gt;Price;
</code></pre>
<p>4.类的外部定义静态成员时，不能重复static关键字，static只出现在类内的声明语句。 此外静态数据成员只能定义一次，所以定义静态数据成员的定义与其他非内联函数的定义 放在同一个文件中。</p>
<p>5.一个常量静态数据成员在类内部被初始化了，一般情况下，在类的外部要不带初始值 地定义一下该成员。<br>例:</p>
<pre><code class="cpp"><span class="keyword">constexpr</span> <span class="keyword">double</span> Meun::tips;
</code></pre>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这篇文主要是记录的《c++ prime》里面第一部分的一些我认为有必要记录下来的关键点，
这里面包括了书上 <span class="keyword">warning</span> 和 note 以及一些我会觉得我将来需要回头的看的部分。
不过收录的并不是很详细，因此这篇文起到的作用更多是一个框架。
</code></pre>]]>
    
    </summary>
    
      <category term="c++" scheme="https://luengzeegin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[输入和输出对象]]></title>
    <link href="https://luengzeegin.github.io/2015/06/06/cin-cout/"/>
    <id>https://luengzeegin.github.io/2015/06/06/cin-cout/</id>
    <published>2015-06-06T02:49:00.000Z</published>
    <updated>2015-07-21T10:03:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="COUT">COUT</h2><pre><code>* Cout-&gt;<span class="annotation">see</span>-<span class="keyword">out</span>，意思就是能看到的输出流，主要用于打印语句。
</code></pre><p>在打印语句结束之后要添加std::endl刷新流，即将在缓冲区的内容输出到屏幕上并且输出一个换行符，<br><strong>（一般情况下 缓冲池即使不用endl刷新，只要遇到另一行表达式，也会自动刷新，<br>不过就没有输出换行符。）</strong>否则数据存储在缓冲区没有得到刷新，从而导致程序崩溃。<br>其中使用  &lt;&lt;  输出运算符，可看成是水流一样将运算符右侧的数据流入cout对象中，<br>并且运算对象可以是多种类型的，可以是算术表达式，也可以是字符串。Etc.</p>
<h2 id="CIN">CIN</h2><a id="more"></a>
<pre><code>* Cin-&gt;<span class="annotation">see</span>-<span class="keyword">in</span>，意思是可见的输入流。
</code></pre><p>C＋＋中cin与cout是绑在一起的，<br>也就是说任何cin的调用都会导致前面的cout关联的缓冲区被刷新<br>。其中使用  &gt;&gt;  输入运算符，可看成是水流一样将缓冲区里面的数据分别流入到运算符右侧的变量里。</p>
<pre><code>* 一次输入过程是这样的：输入数据，按下回车，当系统检测到按下回车的时候，会将输入
 的数据存入输入缓冲区，接着<span class="built_in">cin</span>函数直接从输入缓冲区中取数据。正因为<span class="built_in">cin</span>函数是直接从缓冲区取数据的，
 所以有时候当缓冲区中有残留数据时，<span class="built_in">cin</span>函数会直接取得这些残留数据而不会请求键盘输入。
 此外，<span class="built_in">cin</span>在读取数据时候，遇到读取类型不匹配或者读取到end-of-file的时候也会退出。
</code></pre><h2 id="注意">注意</h2><ul>
<li>在输入多个数据的时候需要用空白符隔开两个数据，不然会同时录入。</li>
<li>在多次输入之间要使用cin.clear()，因为ctrl+z提供的eof符并不会被cin提取，等一次cin从缓冲区读取数据的时候，<br>会首先读取到eof符，从而会退出当前读入，所以后续的读取任务就没办法完成，只能读取到第一次的数据。</li>
<li>在输入字符串的时候，cin以空白符为结束条件，cin.get则以enter为结束条件，类似C语言中的scanf和gets</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="COUT">COUT</h2><pre><code>* Cout-&gt;<span class="annotation">see</span>-<span class="keyword">out</span>，意思就是能看到的输出流，主要用于打印语句。
</code></pre><p>在打印语句结束之后要添加std::endl刷新流，即将在缓冲区的内容输出到屏幕上并且输出一个换行符，<br><strong>（一般情况下 缓冲池即使不用endl刷新，只要遇到另一行表达式，也会自动刷新，<br>不过就没有输出换行符。）</strong>否则数据存储在缓冲区没有得到刷新，从而导致程序崩溃。<br>其中使用  &lt;&lt;  输出运算符，可看成是水流一样将运算符右侧的数据流入cout对象中，<br>并且运算对象可以是多种类型的，可以是算术表达式，也可以是字符串。Etc.</p>
<h2 id="CIN">CIN</h2>]]>
    
    </summary>
    
      <category term="c++" scheme="https://luengzeegin.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何选择类型]]></title>
    <link href="https://luengzeegin.github.io/2015/06/06/my-new-post/"/>
    <id>https://luengzeegin.github.io/2015/06/06/my-new-post/</id>
    <published>2015-06-06T02:19:33.000Z</published>
    <updated>2016-02-22T11:21:51.000Z</updated>
    <content type="html"><![CDATA[<p>首先我们要知道：<br>    <strong>short《 int 《 long 《 long long</strong></p>
<h3 id="那么接下来有几条建议">那么接下来有几条建议</h3><pre><code><span class="number">1.</span> 一般来说，<span class="keyword">long</span>来说跟<span class="keyword">int</span>有一样的尺寸，所以如果数值超过<span class="keyword">int</span>的表示范围，我们可以选择使用longlong
<span class="number">2.</span> 在算术表达式中不要使用<span class="keyword">char</span>或者<span class="keyword">bool</span>，因为<span class="keyword">char</span>在一些机器上面是有符号的，而在一些机器上面是没有记号的，
   如果需要一个不大的整数，那么可以使用<span class="keyword">signed</span> <span class="keyword">char</span> 或者 uns。
<span class="number">3.</span> 执行浮点运算选用<span class="keyword">double</span>，<span class="keyword">float</span> 精度不够之余，速度不见得比<span class="keyword">double</span>快。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>首先我们要知道：<br>    <strong>short《 int 《 long 《 long long</strong></p>
<h3 id="那么接下来有几条建议">那么接下来有几条建议</h3><pre><code><span class="number">1.<]]>
    </summary>
    
      <category term="c++" scheme="https://luengzeegin.github.io/tags/c/"/>
    
  </entry>
  
</feed>