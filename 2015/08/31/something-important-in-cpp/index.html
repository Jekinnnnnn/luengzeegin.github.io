<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="c++," />





  <link rel="alternate" href="/atom.xml" title="备忘录" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="这篇文主要是记录的《c++ prime》里面第一部分的一些我认为有必要记录下来的关键点，
这里面包括了书上 warning 和 note 以及一些我会觉得我将来需要回头的看的部分。
不过收录的并不是很详细，因此这篇文起到的作用更多是一个框架。">
<meta property="og:type" content="article">
<meta property="og:title" content="Note in c++ prime 5th (chap1-7)">
<meta property="og:url" content="https://luengzeegin.github.io/2015/08/31/something-important-in-cpp/index.html">
<meta property="og:site_name" content="备忘录">
<meta property="og:description" content="这篇文主要是记录的《c++ prime》里面第一部分的一些我认为有必要记录下来的关键点，
这里面包括了书上 warning 和 note 以及一些我会觉得我将来需要回头的看的部分。
不过收录的并不是很详细，因此这篇文起到的作用更多是一个框架。">
<meta property="og:updated_time" content="2017-02-15T14:36:01.714Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Note in c++ prime 5th (chap1-7)">
<meta name="twitter:description" content="这篇文主要是记录的《c++ prime》里面第一部分的一些我认为有必要记录下来的关键点，
这里面包括了书上 warning 和 note 以及一些我会觉得我将来需要回头的看的部分。
不过收录的并不是很详细，因此这篇文起到的作用更多是一个框架。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://luengzeegin.github.io/2015/08/31/something-important-in-cpp/"/>

  <title> Note in c++ prime 5th (chap1-7) | 备忘录 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">备忘录</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">苟利国家生死以，岂因祸福避趋之。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '5KNqcS_qiVtdSPs-g3YH','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Note in c++ prime 5th (chap1-7)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-31T16:47:59+08:00" content="2015-08-31">
              2015-08-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/31/something-important-in-cpp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/31/something-important-in-cpp/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <pre><code>这篇文主要是记录的《c++ prime》里面第一部分的一些我认为有必要记录下来的关键点，
这里面包括了书上 <span class="keyword">warning</span> 和 note 以及一些我会觉得我将来需要回头的看的部分。
不过收录的并不是很详细，因此这篇文起到的作用更多是一个框架。
</code></pre><a id="more"></a>
<h2 id="初始化&amp;赋值">初始化&amp;赋值</h2><p>1.初始化不是赋值，初始化的含义是创建变量时赋予它一个初始值，就是为这个变量开辟一个内存空间。而赋值的含义是把对象的当前值擦除，然后用一个新值替代。</p>
<p>2.定义于任何函数体之外的变量被初始化为0，定义于函数内的内置类型的对象，如果没有初始化，它的值则没有定义。此外，类的对象如果没有显式的初始化，则其值由类决定。</p>
<p>3.如果要初始化一个含有元素值的列表，那么只能把初始值都放在花括号里进行列表初始化。</p>
<h2 id="头文件声明">头文件声明</h2><p>1.使用ifndef，可避免重定义，但是在XXXX.h 中的 <strong>.</strong> 要使用下划线 <strong>_</strong> 代替。</p>
<h2 id="定义&amp;声明">定义&amp;声明</h2><p>1.声明是让变量的名字让程序知道，而定义则是创建一个内存空间并且与变量的名字挂钩。此外，一个变量只能定义一次，并且变量的定义只能出现在一个文件中，如果其他文件需要使用就必须对这个变量进行声明。</p>
<h2 id="const">const</h2><p>1.const 对象一旦创建就必须初始化。在默认状态下，const 对象仅在文件内有效，如果想在多个文件里面使用 const 对象，那么必须在变量定义之前添加 extern 。</p>
<p>2.顶层 const 对象的内容是固定不变的，而底层 const 对象的含义是对象拥有 const 这样一种属性。</p>
<p>3.用于声明引用的 const 都是底层 const 。</p>
<p>4.普通的拷入和拷出并不会影响拷贝对象的值，但是底层的 const 的限制执行拷入和拷出操作时，两个对象的数据类型要匹配，或者能进行类型转换。</p>
<p>5.对常量对象取地址是一种底层const。因为常量对象是不允许改变，那么相应的地址也是固定的（在函数体外定义的对象），因此指向他的指针自然也是固定的。</p>
<p>6.对于常量的 const 只能读不能写。</p>
<p>7.当数据不需要修改的时候，最好都要使用常量。</p>
<h2 id="别名声明">别名声明</h2><p>1.传统的方式是用typedef，这里不作赘述，c++11规定一种新的方式：<br>using 别名 = 类型名，<br><strong>注意</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> cpointer = <span class="keyword">char</span> *;</span><br><span class="line">cpointer p1;</span><br><span class="line"><span class="keyword">char</span> *p1;</span><br><span class="line"><span class="comment">//此处两个 p1 并不完全等价</span></span><br><span class="line"><span class="comment">//因为前者的数据类型是指针，而后者数据类型是char 而"*"则是声明符的一部分。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="auto类型符">auto类型符</h2><p>1.使用auto只能声明一个基本类型的多个变量，因此所有变量的初始基本数据类型都是 必须一样。<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>,*p = &amp;i  <span class="comment">// 那个p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>,j = <span class="number">3.14</span>  <span class="comment">// 错误类型不一致</span></span><br></pre></td></tr></table></figure></p>
<p>2.auto一般会忽略顶层const，如果想推断出的auto是顶层就要显式的写明const、 auto，但是在设置为auto型的引用时，初始值中的顶层属性会被保留，不过底层的const会 保留下来。<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">auto</span> a = ci ; <span class="comment">// a为整数被忽略</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = ci ; <span class="comment">// 整型常量引用没被忽略</span></span><br></pre></td></tr></table></figure></p>
<p>3.在auto中，‘*’和‘&amp;’只从属于某个声明符，并不是数据类型的一部分，所以初始值必须是同一个类型。<br>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;m = ci,*p = &amp;ci; <span class="comment">// 正确 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i,*p2 = &amp;ci; <span class="comment">// 错误 int，const int</span></span><br></pre></td></tr></table></figure></p>
<h2 id="decltype类型标识符">decltype类型标识符</h2><p>1.只要decltype((变量名))那出来的都是引用。</p>
<p>2.decltype()括号里面是左值，那么类型就是引用。常见的是decltype(<em>p）假设p是  int</em>  ,那么decltype生成的是 int &amp;</p>
<p>3.constdecltype((i))中，const不会发生作用。<br>这里的<strong>const</strong>修饰的是<strong>decltype((i))</strong>，假设 i 是 int 类型，那么decltype的结果就是<strong>int类型</strong>的引用，那么 const 修饰int型的引用，<br>相当于 <strong>int&amp;  const</strong>，那么为什么不是 <strong>const int&amp;</strong>呢？<br>那是因为 <strong>const int&amp;</strong> 就是对整型常量的引用，改变了 <strong>int&amp;</strong> 的结构，所以两者并不等价。那么我们回到 <strong>int &amp; const</strong>，因为引用本来就不能被修改，因此 <strong>const</strong> 就不起作用，所以 <strong>const decltype</strong> 语句相当于 <strong>int &amp;</strong>。</p>
<p>4.常用于推断已知函数或者表达式的表达式类型，auto 则是根据初始化的值推断对象的类型。</p>
<p>5.当decltype作用于数组类型的时候，它返回是的仍是个数组（类型 + 维度），并不会将数组转换成指针。</p>
<p>6.最好不要用decltype返回一个指针类型，最妥当的方法是：先用decltype返回基类型，然后再加上 <strong>*</strong> 修饰符。</p>
<h2 id="string类">string类</h2><p>1.例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;string&gt; using std::string；</span></span><br><span class="line"><span class="built_in">string</span> s1；</span><br><span class="line"><span class="comment">// 默认初始化是空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(100,'c')</span>； </span><br><span class="line"><span class="comment">// 将s2初始化成100个c的串</span></span><br><span class="line"><span class="built_in">string</span> s2（s1）； </span><br><span class="line"><span class="comment">// 将s2是s1 直接初始化 s2=s1 拷贝初始化</span></span></span><br></pre></td></tr></table></figure></p>
<p>2.string对象会自动忽略开头空白若输入“    abc”则输出结果就是abc。</p>
<p>3.string类相加的时候加号两边的对象至少一个是string。</p>
<p>4.C语言中的字符串字面值跟C++中的string并不是同一样东西。</p>
<p>5.只要操作数里面含有string类，那么就应该加上#include<string>。</string></p>
<p>6.std里面的toupper只支持单个字符，而boost中里面则支持vector。</p>
<p>7.可使用 <strong>c_str</strong> 成员函数将 string 转换成 <strong>char</strong>，但是一旦 string 改变这个 <strong>char</strong> 就有失效的可能，因此要用这个返回的<strong>char</strong> 最好先备份一下。    </p>
<p>8.对于使用 string 的元素，最好设置为引用类型，可以避免对元素的拷贝。</p>
<p>9.构造 string 的其他方法详见 c++ prime 5th 中文版的321页。</p>
<p>10.如果我们从一个 const *char 创建 string 时 ，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们在构造数组时不传递计数值并且数组也未以空字符结尾，或者计数值大于数组大小，那么构造函数的行为是未定义的。</p>
<p>11.修改 string 的操作详见 c++ prime 5th 中文版的323页。</p>
<p>12.string 子字符串的操作 substr 详见 c++ prime 5th 中文版的322页。</p>
<p>13.assign 总是替换 string 中所有内容， append 总是将新字符追加到末尾。</p>
<p>14.string 的搜索操作详见 c++ prime 5th 中文版的325页。</p>
<p>15.每个搜索操作都会返回一个 <em>string::size_type</em> 表示位置下标，如果搜索失败则返回一个 <em>string::npos</em> 的 <em>const static</em> 成员数据类型为 unsigned，大小初始化为-1。</p>
<p>16.如果要搜索第一个不在参数中的字符，我们应该调用 <em>find_first_not_of</em> </p>
<p>17.如果要搜索与给定 string 中任何一个字符匹配的最后一个字符，那么我们应该调用 <em>find_last_of</em></p>
<p>18.如果要搜索最后一个不出现在给定 string 中的字符，那么我们应该调用 <em>find_last_not_of</em> 。</p>
<p>19.string比较的相关操作详见c++ prime 5th的327页。</p>
<p>20.string 和 数值之间的转换详见c++ prime 5th 的328页。</p>
<p>21.如果 string 不能转换为一个数值，这些函数抛出一个 <em>invalid_argument</em> 异常，如果转换得到的数值无法用任何类型表示，则抛出一个 <em>out_of_range</em> 的异常。</p>
<h2 id="getline">getline</h2><p>1.getline遇到换行符则结束读取操作并返回结果，尽管一开始就是换行符，但是用于接收的string是不会存入换行符。</p>
<p>2.getline 不会跳过前导空格，可以使用 substr 跳过前导空格。</p>
<h2 id="string-size">string.size</h2><p>1.返回的是字符串中字符的个数，注意如果一条表达式中已经有了 size() 函数的话，就不要使 用int了，因为 size 返回的 unsigned int 如果返回值与一个有符号整数比较的话，容易出问题。</p>
<h2 id="vector容器">vector容器</h2><p>1.假如 vector 的元素仍是vector的话，旧式声明是：vector<vector<int>空格&gt; ,<br>新式的声明则是：vector<vector<int>&gt; 。</vector<int></vector<int></p>
<p>2.使用 vector<int> ivec(10,1) 来批量初始化。</int></p>
<p>3.vector 初始化如果用的是圆括号，那么提供的值就是用来说明这个 vector 对象元素的个数和初始值；如果 vector 初始化用的是花括号，那么就是一个 vector 对象元素里面的初始值。注意对于 vector 的初始化不宜使用拷贝初始化，应该使用直接初始化。</p>
<p>4.向 vector 对象中添加元素时不能使用范围for循环。要用 while 或者普通循环，接着一定 要使用 push_back 函数推入 vector 的尾部，而不能用下标法给 vector 对象赋值，<br>因为一个空的 vector 对象不含任何元素。</p>
<p>5.vector对象的类型总是要包括元素的类型。<br>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="keyword">size_t</span>ype;  <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::<span class="keyword">size_t</span>ype;       <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p>
<p>6.可以使用以下形式，使用数组来初始化vector：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; testing(begin(a), end(a)); 	<span class="comment">// begin返回的是一个地址</span></span><br></pre></td></tr></table></figure></p>
<p>7.当返回值是一个vector的时候，应该使用引用形式。<br>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vectorIn,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vectorOut)</span></span></span><br></pre></td></tr></table></figure></p>
<p>8.vector 中元素必须连续保存，所以在增容的时候，容器必须分配新的内存空间来保存已有元素和新元素，将已有元素旧位置移动到新空间中，然后添加新元素，释放旧存储空间。</p>
<p>9.每个vector都可以选择自己的内存分配策略，但是只有当迫不得已的情况下才可以分配新的内存空间。</p>
<p>10.push_back 向 vector 添加元素的操作具有高效率，在一个空的 vector 上调用 n 次 push_back 来创建一个 n 个元素的  vector 所花费的时间不能超过 n 的常数倍。</p>
<h2 id="迭代器">迭代器</h2><p>1.迭代器中end成员返回的是容器尾元素的下一个位置的迭代器，虽然这个尾迭代器不 包括在容器里面，但是它起到一个标志的作用，<br>因此并不能对这个尾迭代器进行运算。</p>
<p>2.迭代器的类型分别为 <em>const_iterator</em> 和 <em>iterator</em> 前者能读取对象的值，但是不能修改它的值，后者既能读写又能修改。</p>
<p>3.cbegin 和 cend 两个函数，不论原来的 string 或者是 vector 是否为常量，    这个函数的 返回值都是 <em>const_iterator</em>。</p>
<p>4.迭代器的类型是类，然后又要访问它的成员的话，那么可以类比结构体指针 使用<strong>-&gt;</strong>箭头运算符。</p>
<p>5.任何一种可能改变vector容量的操作，都会这个对象的迭代器失效。</p>
<h2 id="数组">数组</h2><p>1.在 cstddef 里面定义了 <strong>size_t</strong> 类型——足够大的无符号数字来表示下标。</p>
<p>2.在数组里面用begin和end函数来返回数组的首指针还有尾元素下一位置的指针，<br>使用方法 ：*beg=begin（数组名），<br>两个函数都包含在iteartor头文件中。</p>
<h2 id="下标">下标</h2><p>1.标准库类型的下标必须是无符号类型，而内置的下标运算不是无符号类型，就是可以用负号，就是下列代码可以通过运行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> k = p[-<span class="number">2</span>]; </span><br><span class="line"><span class="comment">// p是a数组a的第三个元素的地址，k就是指向数组的第一个元素。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="左值和右值">左值和右值</h2><p>1.<em>p生成的是左值：p是指针对象存储的是<strong>指向的地址</strong>，</em>p取出这个地址，所以生成的是左值<br>2.&amp;p生成的是右值：取p的地址赋给指针对象，即生成的是<strong>对象的内容</strong>，所以生成的是右值。</p>
<h2 id="布尔运算">布尔运算</h2><p>1.先给两行代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">bool</span> b2 = -b ; <span class="comment">//b2也是true</span></span><br><span class="line"><span class="comment">//b是true意味着整型值是1，那么-b的整型值就是-1，-1的bool值是true。</span></span><br></pre></td></tr></table></figure></p>
<p>2.进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象。</p>
<h2 id="取余运算">取余运算</h2><p>m%(-n) 等 于m%m </p>
<p>(-m)%n 等于 -(m%n)</p>
<h2 id="sizeof运算符">sizeof运算符</h2><p>1.对char或者类型为char的表达式执行sizeof运算，结果为1。</p>
<p>2.对引用类型执行sizeof运算得到被引用对象所占空间的大小。</p>
<p>3.对指针执行sizeof运算得到指针本身所占空间的大小，int型指针64位就是4</p>
<p>4.对解引用指针(<em>p)执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。 
</em>p-&gt;a ，结果就是a的大小。</p>
<h2 id="命名的强制类型转换">命名的强制类型转换</h2><p><strong>cast-name<type>(expression)</type></strong></p>
<p>1.static_cast:任何具有明确类型定义的类型转换，只要不包括底层const都可以用这个，特别是在 <strong>较大算术类型转换为较小</strong> 的时候很有用。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = &amp;d; <span class="keyword">double</span> *db = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<p>2.const_cast:只能改变运算对象的底层const，简单的说就是去掉const的形式，将一个<strong>常量对象改为 非常量对象</strong>。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p; <span class="keyword">char</span> *dp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<p>3.reinterpret_cast：运算对象的位模式提供较低层次上的重新解释 <em>（这个坑先留着）</em></p>
<h2 id="switch_内部的变量定义">switch 内部的变量定义</h2><p>1.为了防止变量的初始化和使用域不在一个块上，<br>所以switch 内部的变量定义的方法应该是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">true</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">string</span> file_name = get_file_name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 加上一个花括号</span></span><br></pre></td></tr></table></figure></p>
<p>流<br>-</p>
<p>所谓流，我们可以把它跟我们生活中的水流类比，<br>重载运算符 &gt;&gt;就很好的说明了这个特征，我感觉这个 &gt;&gt; 运算符就好像波浪啊。在数据结构里面，其实链表也算是一种流的形式，每个表直接都有连接，一环扣一环，得知前一个表才能找到后一个表的方向。所以我们在操作流的时候不妨类比一下链表的操作，说不定会有新的发现。</p>
<h2 id="函数的返回">函数的返回</h2><p>1.在含有return语句的循环后面应该也有一条return语句，如果没有的话，在程序不进入这个循环的时候，那么这个程序就会出错。</p>
<p>2.不要返回局部对象的引用或指针，因为局部对象或者指针都存放在一个临时的空间里 ， 一旦函数结束之后，这部分空间就会收回，那么局部对象就会消失。</p>
<h2 id="重载">重载</h2><p>1.重载依赖于匹配，当不存在精确匹配的时候，则选择最优匹配，如果存在两个“最优” 匹配，那么就会出现二义性错误。</p>
<p>2.一个拥有顶层const的形参无法和另一个没有顶层const的形参区分。<br>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(<span class="keyword">int</span> *)</span></span><br><span class="line"><span class="keyword">int</span> <span class="title">lookup</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> )</span></span><br><span class="line"><span class="comment">// 以上两个声明都是等价的。</span></span></span><br></pre></td></tr></table></figure></p>
<p>3.如果形参是某种类型的引用或者是指针类型，那么根据是非常量对象还是常量对象可以实现函数的重载，这是const是底层的。</p>
<p>4.const_cast能将返回类型是const的函数，变成返回非常量的函数。</p>
<h2 id="默认实参">默认实参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> sz = <span class="built_in">string</span>::<span class="keyword">size_t</span>ype;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = 24 , sz wid = 80 , <span class="keyword">char</span> backgrnd = ' ')</span></span>;</span><br><span class="line"><span class="comment">//调用的时候只需：window = screen() 则自动调用默认参数</span></span><br></pre></td></tr></table></figure>
<p>1.一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p>2.函数后续的声明只能为没有默认值的形参添加默认实参，同时该形参右侧的所有形参 都要有默认值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window = screen(, , <span class="string">'?'</span>);	<span class="comment">//错误：只能省略尾部的实参</span></span><br><span class="line">window = screen(<span class="string">'?'</span>);		<span class="comment">// 调用screen('?' ,80,' ')</span></span><br><span class="line">window = screen(<span class="number">66</span> , <span class="number">128</span> , <span class="string">'#'</span>); <span class="comment">//正确调用</span></span><br></pre></td></tr></table></figure></p>
<p>3.默认形参只能被赋予一次，我们不能修改一个已经存在的默认实参。</p>
<p>4.在使用默认实参时，尽量把经常需要修改的参数放在前面，把不怎么需要经常修改的  参数放在后面，同时要在函数声明中指明默认实参，并将该声明放在合适的头文件中。</p>
<p>5.默认实参已经在函数定义处设置好，局部变量并不能影响默认实参。</p>
<h2 id="内联函数与constexpr函数">内联函数与constexpr函数</h2><p>1.内联函数可以避免函数调用的开销，适用于规模较小，流程直接，频繁调用的函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp;</span><br><span class="line">shorterString(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; shorterString(s1,s2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>2.constexpr函数的返回类型及所有形参的类型都要是字面值类型，不过constexpr函数的返回值不一定是常量表达式。</p>
<h2 id="程序调试">程序调试</h2><p>1.assert处理宏定义在cassert里，assert(expr)首先对expr求值，如果为假，程序终止 并输出信息，如果为真则assert什么也不做。</p>
<p>2.assert与预处理命令NDEBUG有关系，NDEBUG -&gt; no debug 关闭调试状态，一般来说系统默认是启用调试状态的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span>  NDEBUG <span class="comment">//关闭调试状态</span></span></span><br></pre></td></tr></table></figure></p>
<p>3.在使用assert的时候，最好不要连续多次使用assert，因为assert每次只能判断一个条件，这样不利于判断究竟程序在哪一个assert出了问题。</p>
<p>类<br>-</p>
<p>1.类的基本思想是数据抽象和封装，因此调用类有点类似于调用函数，不过身为类的作者还要思考如何做好数据的抽象。</p>
<p>2.类的成员函数的声明必须在类的内部，但是类的定义既可以在类的内部也 可以在类的外部。</p>
<p>3.一般来说，如果非成员函数是类接口的组成部分，则这些函数的生命应该与类在同一个头文件里。</p>
<p>4.当成员函数需要使用其他类型的时候，如果使用其他类的的时候我们需要使用引用，如果我们的操作会改变这个类的内容那么就要设置为普通引用，否则设置为常量引用。在对普通引用数据进行处理的时候，如果我们不想损坏原有数据，那么我们可以将这个对象拷贝给一个新建的副本，然后再进行处理，然后返回这个副本即可。</p>
<p>5.访问说明符public之后的成员在整个程序内可被访问，多数用来定义类的接口，访问说明符<strong>private</strong>可以被类的成员函数或者友元访问多数用来定义类的数据类型。</p>
<p>6.class关键字默认访问权限是 private，struct 关键字默认权限 public 。</p>
<p>7.定义在类内部的成员函数是自动inline，不过最好在<strong>类外部</strong>定义的地方说明inline，并且 inline 的成员函数也应该与相应的类定义在同一个头文件之中。</p>
<p>8.在类中初始化成员的时候用 “ = “  初始化数据成员，用” { } “ 初始化容器。</p>
<p>9.序列调用中，前一个调用函数的返回对象要与后一个调用函数的对象要相兼容或者一致。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myScreen.move(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">'#'</span>)；</span><br><span class="line"><span class="comment">//move 和 set 函数都是返回 screen 的引用，</span></span><br><span class="line"><span class="comment">//如果前者是 const&amp; ,而后者 set 调用的非常量对象，那么这个序列调用将会报错。</span></span><br></pre></td></tr></table></figure></p>
<p>10.在序列调用中，如果调用函数不是引用类型而是普通类型，那么这个函数返回的不是对象本身而是对象的一个副本。相当于整个函数调用完之后原来的对象并没有发现改变，发生改变的是函数调用的时候生成的一个临时值。</p>
<p>11.一旦一个类的名字出现后，它就被认为是声明过了(但没有定义)，因此类里面允许包含指向它自身类型的引用或指针。简单的说就是 class foo 或 struct bar 出现之后，在foo和bar的 { } 中就用 “ foo <em>“ 和 “ bar </em>“</p>
<p>12.要是a类中要调用b类中的成员函数，那么b要在a之前声明。</p>
<p>13.当函数定义在类的外部的时候，返回类型中使用的名字都位于类的作用域之外，这是要用” :: “指明它是哪个类的成员。</p>
<p>14.编译器处在完里中的全部声明之后才会处理成员函数的定义。</p>
<p>15.在类中类型名的定义通常出现在类的开始处，并且如果类里面使用了外层作用域中表示类型的名字，那么类之后不能重新定义该名字。</p>
<p>16.在成员函数中如果对象名与外层作用域中重复，但是我们又需要用到这个外层作用域中的对象，<br>那么我们可以用作用域运算符<strong>::</strong>强制访问外层对象，类中的对象同理，不过也可以也用this指针强制访问成员。    </p>
<p>17.在类成员中如果是const、引用、或者属于某种类型未提供默认构造函数的类类型，那么我们必须通过构造函数初始值列表为这些成员提供初始值。</p>
<h2 id="友元">友元</h2><p>1.友元的声明只能出现在类定义的内部，最好在类定义开始或者结束的位置集中声明友元，这样容易知晓友元的具体情况。为了使友元对类用户可见，我们通常把友元的声明与类的本身放置在同一个头文件中。</p>
<p>2.友元关系不存在传递性，每个类负责控制自己的友元类或友元函数。</p>
<p>3.当一个名字出现在一个友元声明中，我们隐式地假定该名字在当前作用域中是可见的。</p>
<p>4.类内友元声明与定义作用域在类之中，若成员函数在外部定义时要调用友元函数，那么在外部也要声明友元函数。</p>
<h2 id="this指针">this指针</h2><p>1.类的成员函数通过 this 指针来访问调用它那个对象，任何自定义名为 this 的参数或者变量的行为都是非法的，一般情况下 this 的类型都是指向类类型非常量版本的常量指针，如果我们需要调用一个返回常量的成员函数，我们需要把 const 关键字放在函数的参数列表之后，这样以后， this 指针将是一个指向常量的指针。</p>
<p>2.我们无须使用this指针来访问某一个特定的调用者的成员，而是需要把调用函数的对象当作一个整体使用，即返回时我们应该 return *this。</p>
<p>3.在类要使用某一个private成员，可以直接使用，因为在类中this是隐式使用的。</p>
<h2 id="构造函数">构造函数</h2><p>1.构造函数没有返回类型，且构造函数不能声明成const，它的作用类似于回调函数(在类对象(A层)中调用构造函数(B层)初始化类对象(A层))起到一个接口的作用。</p>
<p>2.如果我们没有创造一个构造函数，那么编译器会给我们创造一个默认构造函数，但是对于指针或者数组来说这样的默认构造函数是存在风险的。</p>
<p>3.如果一个类在某种特定的情况下需要控制对象初始化，那么我们就要定义一个默认 的构造函数。</p>
<p>4.如果 “ = default “ 在类的内部，则默认构造函数是内联的，相反，如果它在类的外部那么默认不是内联。</p>
<p>5.构造函数不应该轻易覆盖掉类内初始值，除非新赋的值跟原值不一样，如果我们不能使用类内初始值（指针），则所有构造函数都应该显式的初始化每个内置的成员，而且我们应该使用构造函数的初始值，避免出现 const 、引用这种因未绑定而出现的错误。</p>
<p>6.构造函数初始值的顺序与成员声明的顺序保持一致，所以尽量避免使用某些成员初始化 其他成员。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> X </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    X(<span class="keyword">int</span> val) : j(val) , i(j) &#123; &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//初始化失败，因为i先被初始化，不能用未初始化的j来初始化i。</span></span><br></pre></td></tr></table></figure></p>
<p>7.在委托构造函数中，如果函数体中包含代码的话，那么先执行的受委托构造函数的初始值列表，然后是受委托函数的的函数体，最后才是委托者的函数体。例子可以<a href="http://blog.csdn.net/qq844352155/article/details/27121951" target="_blank" rel="external">看这里</a></p>
<p>8.如果vector对象中是类类型，那么这个类一定至少包含一个默认构造函数来初始化 这个对象。</p>
<h2 id="explicit关键字">explicit关键字</h2><p>1.这个关键字只对一个实参的构造函数有效，因为需要多个实参的构造函数不能用于执行隐式转换。</p>
<p>2.只能在类内声明构造函数的时候使用explicit关键字，在类外部定义构造函数不应重复。</p>
<p>3.使用explicit关键字声明构造函数后，这个构造函数只能以直接初始化的形式使用，不能使用赋值初始化，并且编译器将不会再自动转换过程中使用该构造函数。</p>
<p>4.关于explicit关键字我觉得有一篇博文写的很清楚，欢迎大家过去看一看，就能理解了。<a href="http://www.programlife.net/cpp-explicit-keyword.html" target="_blank" rel="external">传送门</a></p>
<h2 id="聚合类(结构体)">聚合类(结构体)</h2><p>1.显示地初始化类的对象成员时，在添加或者删除一个成员之后，所有的初始化语句都需要更新。</p>
<h2 id="constexpr构造函数">constexpr构造函数</h2><p>1.constexpr构造函数体一般来说是空的，因为构造函数是回调函数不能包含返回语句，而constexpr函数唯一可执行的语句就是返回语句。</p>
<h2 id="类的静态成员">类的静态成员</h2><p>1.类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。<br>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Meun</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 省略若干构造函数与接口</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">int</span> SaleNum ；</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">double</span> Price = <span class="number">8.6</span>；</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> tips = <span class="number">3.8</span> ;</span><br><span class="line"><span class="comment">//当Meun初始化的时候这个对象就包含SaleNum，</span></span><br><span class="line"><span class="comment">//而Price成员被所有Meun对象共享。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.因为静态成员不与任何对象绑定在一起，它们不包含this指针，所以静态成员不能声明称const，而且也不能在static函数体内使用this指针，这个限制不但适用在this指针的显式使用，而且对调用非静态成员函数的隐式使用有效。</p>
<p>3.我们可以通过使用域运算符直接访问静态成员，也可以通过类的某个对象的引用或者指针来访问静态成员。<br>例：</p>
<pre><code class="cpp">Meun foo;
Meun *foopointer = &amp;foo;
<span class="keyword">double</span> t = foo.Price;
<span class="keyword">double</span> t = foopointer-&gt;Price;
</code></pre>
<p>4.类的外部定义静态成员时，不能重复static关键字，static只出现在类内的声明语句。 此外静态数据成员只能定义一次，所以定义静态数据成员的定义与其他非内联函数的定义 放在同一个文件中。</p>
<p>5.一个常量静态数据成员在类内部被初始化了，一般情况下，在类的外部要不带初始值 地定义一下该成员。<br>例:</p>
<pre><code class="cpp"><span class="keyword">constexpr</span> <span class="keyword">double</span> Meun::tips;
</code></pre>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag">#c++</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/06/06/cin-cout/" rel="next" title="输入和输出对象">
                <i class="fa fa-chevron-left"></i> 输入和输出对象
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/08/31/keywords-in-cpp/" rel="prev" title="keywords in cpp(part one)">
                keywords in cpp(part one) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/08/31/something-important-in-cpp/"
           data-title="Note in c++ prime 5th (chap1-7)" data-url="https://luengzeegin.github.io/2015/08/31/something-important-in-cpp/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/11225229?v=3&u=b3c447bfe8d0842bfc56483c05540fe69ebed1f6&s=140"
               alt="Lueng Zeegin" />
          <p class="site-author-name" itemprop="name">Lueng Zeegin</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/luengzeegin" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/liang-zi-jian-48" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  ZhiHu
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化&赋值"><span class="nav-number">1.</span> <span class="nav-text">初始化&赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#头文件声明"><span class="nav-number">2.</span> <span class="nav-text">头文件声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义&声明"><span class="nav-number">3.</span> <span class="nav-text">定义&声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">4.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#别名声明"><span class="nav-number">5.</span> <span class="nav-text">别名声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#auto类型符"><span class="nav-number">6.</span> <span class="nav-text">auto类型符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decltype类型标识符"><span class="nav-number">7.</span> <span class="nav-text">decltype类型标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类"><span class="nav-number">8.</span> <span class="nav-text">string类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getline"><span class="nav-number">9.</span> <span class="nav-text">getline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-size"><span class="nav-number">10.</span> <span class="nav-text">string.size</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector容器"><span class="nav-number">11.</span> <span class="nav-text">vector容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">12.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">13.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下标"><span class="nav-number">14.</span> <span class="nav-text">下标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#左值和右值"><span class="nav-number">15.</span> <span class="nav-text">左值和右值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔运算"><span class="nav-number">16.</span> <span class="nav-text">布尔运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取余运算"><span class="nav-number">17.</span> <span class="nav-text">取余运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof运算符"><span class="nav-number">18.</span> <span class="nav-text">sizeof运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名的强制类型转换"><span class="nav-number">19.</span> <span class="nav-text">命名的强制类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch_内部的变量定义"><span class="nav-number">20.</span> <span class="nav-text">switch 内部的变量定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的返回"><span class="nav-number">21.</span> <span class="nav-text">函数的返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载"><span class="nav-number">22.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认实参"><span class="nav-number">23.</span> <span class="nav-text">默认实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数与constexpr函数"><span class="nav-number">24.</span> <span class="nav-text">内联函数与constexpr函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序调试"><span class="nav-number">25.</span> <span class="nav-text">程序调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#友元"><span class="nav-number">26.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针"><span class="nav-number">27.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">28.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit关键字"><span class="nav-number">29.</span> <span class="nav-text">explicit关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚合类(结构体)"><span class="nav-number">30.</span> <span class="nav-text">聚合类(结构体)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr构造函数"><span class="nav-number">31.</span> <span class="nav-text">constexpr构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的静态成员"><span class="nav-number">32.</span> <span class="nav-text">类的静态成员</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lueng Zeegin</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luengzeegin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
